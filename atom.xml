<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>answerend42的Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://answerend42.github.io/"/>
  <updated>2020-10-20T16:23:14.619Z</updated>
  <id>http://answerend42.github.io/</id>
  
  <author>
    <name>answerend42</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>P4170 [CQOI2007]涂色</title>
    <link href="http://answerend42.github.io/2020/10/21/lg4170/"/>
    <id>http://answerend42.github.io/2020/10/21/lg4170/</id>
    <published>2020-10-20T16:10:56.000Z</published>
    <updated>2020-10-20T16:23:14.619Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>假设你有一条长度为 $5$ 的木版，初始时没有涂过任何颜色。你希望把它的 $5$ 个单位长度分别涂上红、绿、蓝、绿、红色，用一个长度为 $5$ 的字符串表示这个目标：<code>RGBGR</code>。</p><p>每次你可以把一段连续的木版涂成一个给定的颜色，后涂的颜色覆盖先涂的颜色。例如第一次把木版涂成 <code>RRRRR</code>，第二次涂成 <code>RGGGR</code>，第三次涂成 <code>RGBGR</code>，达到目标。</p><p>用尽量少的涂色次数达到目标。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入仅一行，包含一个长度为 $n$ 的字符串，即涂色目标。字符串中的每个字符都是一个大写字母，不同的字母代表不同颜色，相同的字母代表相同颜色。($1≤n≤50$)</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>仅一行，包含一个数，即最少的涂色次数。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>初始为空，要达到最终状态，我们总是需要选择<strong>一段</strong>涂上颜色。可以很快想到用区间 $\text{DP}$。</p><p>考虑这么一个问题，若给定状态中只用涂上一个字符，我们一定只用涂一次。这也就是边界条件 $f_{i,i}=1$。</p><p>而对于颜色相同而非同一个字符的情况，多涂一个总是无伤大雅的，也就是 $f<em>{i,j}=\min(f</em>{i+1,j},f_{i,j-1})$。</p><p>总后也就是我们常用的区间 $\text{DP}$，枚举一个分割点进行 $\text{DP}$。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">105</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">f[l][r]  = min&#123; f[l + 1][r], f[l][r - 1] &#125;(a[l] = a[r]),</span></span><br><span class="line"><span class="comment">min&#123; f[l][k] + f[k + 1][r], f[l][r] &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, a + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> length = <span class="built_in">strlen</span>(a + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= length; i++) f[i][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">1</span>; len &lt; length; len++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l + len &lt;= length; l++) &#123;</span><br><span class="line">            <span class="keyword">int</span> r = l + len;</span><br><span class="line">            <span class="keyword">if</span> (a[l] == a[r])</span><br><span class="line">                f[l][r] = min(f[l + <span class="number">1</span>][r], f[l][r - <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = l; k &lt; r; k++) f[l][r] = min(f[l][k] + f[k + <span class="number">1</span>][r], f[l][r]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, f[<span class="number">1</span>][length]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;假设你有一条长度为 $5$ 的木版，初始时没有涂过任何颜色。你希望把它的 $5$ 个单位长度分别涂上红、绿、蓝、绿、红色，用
      
    
    </summary>
    
    
      <category term="题解" scheme="http://answerend42.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="动态规划" scheme="http://answerend42.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="区间DP" scheme="http://answerend42.github.io/tags/%E5%8C%BA%E9%97%B4DP/"/>
    
  </entry>
  
  <entry>
    <title>P6832 [Cnoi2020]子弦</title>
    <link href="http://answerend42.github.io/2020/10/20/lg6382/"/>
    <id>http://answerend42.github.io/2020/10/20/lg6382/</id>
    <published>2020-10-20T15:50:38.000Z</published>
    <updated>2020-10-20T16:12:37.574Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P6833" target="_blank" rel="noopener">题目链接</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Cirno 有一个字符串 $\texttt{S}$，并希望你能求出 $\texttt{S}$ 出现次数最多的非空子串的出现次数，记作 $p$。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>一行，一个字符串 $\texttt{S}$。($ 0&lt; |\texttt{S}| \le 10^7,\texttt{S}_x\in[\texttt{a},\texttt{z}]$)</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一行，一个整数 $p$。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>对于长度为一符串，有且仅有一个子串为最大。对于长度大于一的字符串的子串，总包含了单个字母为子串，也就保证了单个字母作为子串总是最大的，因此，只用统计单个字母出现的最大次数。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e7</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> ans, a[<span class="number">30</span>];</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        a[s[i] - <span class="string">'a'</span>]++;</span><br><span class="line">        ans = max(ans, a[s[i] - <span class="string">'a'</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P6833&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerl
      
    
    </summary>
    
    
      <category term="题解" scheme="http://answerend42.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="字符串" scheme="http://answerend42.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="贪心" scheme="http://answerend42.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>初赛复习集合</title>
    <link href="http://answerend42.github.io/2020/10/07/%E5%88%9D%E8%B5%9B%E5%A4%8D%E4%B9%A0%E9%9B%86%E5%90%88/"/>
    <id>http://answerend42.github.io/2020/10/07/%E5%88%9D%E8%B5%9B%E5%A4%8D%E4%B9%A0%E9%9B%86%E5%90%88/</id>
    <published>2020-10-07T14:07:39.000Z</published>
    <updated>2020-10-20T16:23:53.541Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CSP-S-2019"><a href="#CSP-S-2019" class="headerlink" title="CSP/S-2019"></a>CSP/S-2019</h2><p><img src="https://i.loli.net/2020/10/07/XGtg8WTaAPBIY62.png" alt="image-20201007220800359"></p><p>​    Dijkstra 需要选取最近的 <code>d[s]</code>，Floyd 不需要任何贪心，Prim 同 Dijkstra，Kruskal 需要选取最短的边</p><p><img src="https://i.loli.net/2020/10/07/ulo9sYA4c3MTkhF.png" alt="image-20201007224328405"></p><p>第 4 题中，如果给定 $a=b$，那么 <code>cnt[i]</code> 会变成原先的两倍可能会超出 $n$<br>第 6 题中，要知道并查集不带路径压缩的最坏时间复杂度是 $\mathcal O(n)$ 的，那么执行 $n$ 次也就是 $\mathcal O(n^2)$ 的</p><h2 id="模拟题自测"><a href="#模拟题自测" class="headerlink" title="模拟题自测"></a>模拟题自测</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3、下列说法错误的是（）。</span><br><span class="line">A、栈和队列的存储方式既可是顺序方式，也可是链式方式</span><br><span class="line">B、线性表在物理存储空间中不一定是连续的</span><br><span class="line">C、二叉树中每个节点的两棵子树高度差为1</span><br><span class="line">D、对于一棵非空二叉树，它的根节点作为第一层，则第i层至多有2^(i-1)个节点</span><br></pre></td></tr></table></figure><p>​    显然选 C，因为很容易举出反例。</p><p><img src="https://i.loli.net/2020/10/09/rYGOepZQksqN68m.png" alt="image-20201009004906424"></p><p><code>memset(a,255,sizeof(a))</code> 等价于将 a 全部赋值为 $-1$ </p><h2 id="一些知识点总结"><a href="#一些知识点总结" class="headerlink" title="一些知识点总结"></a>一些知识点总结</h2><h3 id="局域网、城域网、广域网、个人局域网"><a href="#局域网、城域网、广域网、个人局域网" class="headerlink" title="局域网、城域网、广域网、个人局域网"></a>局域网、城域网、广域网、个人局域网</h3><ul><li>LAN：局域网</li><li>MAN：城域网</li><li>WAN：广域网</li><li>PAN：个人局域网</li></ul><p>RAM 中的信息是 <strong>计算机工作时随机写入的</strong>（NOIP2000 普及）</p><p>用静电吸附墨粉后转移到纸张上，是 <strong>激光打印机</strong> 的工作方式（NOIP 2004）</p><p>彩色图像以位图形式保存时，若色深为 $n$，分辨率为 $x \times y$，则为 $n \times x \times y$ bit</p><ul><li>1B=8bit</li><li>1KB=1024B</li><li>1MB=1024KB</li><li>1GB=1024MB</li><li>1TB=1024GB</li></ul><h3 id="二叉树的若干性质"><a href="#二叉树的若干性质" class="headerlink" title="二叉树的若干性质"></a>二叉树的若干性质</h3><ul><li>在二叉树的第 $i$ 层上最多有 $2^{i-1}$ 个结点（$i \ge 1$）</li><li>深度为 $k$ 的二叉树至多有 $2^{k} - 1$ 个结点（满二叉树）</li><li>对于任意一棵二叉树，如果其叶结点数为 $n_0$，而度数为 $2$ 的结点总数为 $n_2$，则有 $n_0=n_2+1$</li><li>具有 $n$ 个结点的完全二叉树的深度为 $\lfloor \log_2n \rfloor+1$</li></ul><h3 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h3><p>前序遍历：根结点 左子树 右子树<br>中序遍历：左子树 根结点 右子树<br>后序遍历：左子树 右子树 根结点</p><h4 id="知前序、中序"><a href="#知前序、中序" class="headerlink" title="知前序、中序"></a>知前序、中序</h4><p>前序：ABCDEFG<br>中序：CBEDAFG<br>前序找到 A 为根，在中序中找到左子树 BCDE、右子树 FG<br>前序找到 B 为根，在中序中找到左子树 C、右子树 DE<br>前序找到 D 为根，在中序中找到左子树 E、无右子树<br>前序找到 F 为根，在中序中找到右子树 G、无左子树</p><p><img src="https://i.loli.net/2020/10/09/9xLqbzh7PcndkaG.png" alt="image-20201009012139226"></p><h4 id="知后序、中序"><a href="#知后序、中序" class="headerlink" title="知后序、中序"></a>知后序、中序</h4><p>后序：ABFHGEDC<br>中序：ABCEFGHD<br>后序找到 C 为根，在中序中找到左子树 AB、右子树 EFGHD<br>后序找到 B 为根，在中序中找到左子树 A、无右子树<br>后序找到 D 为根，在中序中找到左子树 EFGH、无右子树<br>后序找到 E 为根，在中序中找到右子树 FGH、无左子树<br>后序找到 G 为根，在中序中找到左子树 F、右子树 H</p><p><img src="https://i.loli.net/2020/10/09/35YxNhmUeLFvgWr.png" alt="image-20201009012850075"></p><h3 id="排列组合"><a href="#排列组合" class="headerlink" title="排列组合"></a>排列组合</h3><script type="math/tex; mode=display">P_n^k=\dfrac{n!}{(n-k)!}\\C_{n}^{k}=\binom{n}{k}=\dfrac{P_{n}^{k}}{P_{k}^{k}}=\dfrac{n!}{k!(n-k)!}\\S(n,m)=\begin {Bmatrix} n \\ m\end {Bmatrix}={\frac 1 {m!}}\sum_{k=0}^m (-1)^k\binom{m}{k}(m-k)^n</script><script type="math/tex; mode=display">\binom{7}{2}</script><hr><p>1</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;CSP-S-2019&quot;&gt;&lt;a href=&quot;#CSP-S-2019&quot; class=&quot;headerlink&quot; title=&quot;CSP/S-2019&quot;&gt;&lt;/a&gt;CSP/S-2019&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/10/0
      
    
    </summary>
    
    
      <category term="记录" scheme="http://answerend42.github.io/categories/%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="初赛" scheme="http://answerend42.github.io/tags/%E5%88%9D%E8%B5%9B/"/>
    
      <category term="集合" scheme="http://answerend42.github.io/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>P1535 【[USACO08MAR]Cow Travelling S】</title>
    <link href="http://answerend42.github.io/2020/10/06/lg1535/"/>
    <id>http://answerend42.github.io/2020/10/06/lg1535/</id>
    <published>2020-10-06T15:21:40.000Z</published>
    <updated>2020-10-06T15:59:20.139Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1535" target="_blank" rel="noopener">原题链接</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>​    给定两点 $(x_1,y_1),(x_2,y_2)$，规定不超过 $t$ 步求从第一个点到第二个点的路径条数。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>​    看上去就能搜，问题是超时是无法避免的，重点在于考虑如何优化。</p><p>​    这里提供一个看似无关紧要但卡常很实用的范围判断优化。对于判断 $x \in [l,r]$，一种常规写法是 <code>l&lt;=x&amp;&amp;x&lt;=r</code>，实际上有更快的写法是 <code>(x-l)|(r-x)&gt;=0</code>，具体原理可以参考<a href="https://www.zhihu.com/question/27417946/answer/1253126563" target="_blank" rel="noopener">韦易笑的知乎回答</a>、<a href="https://zhuanlan.zhihu.com/p/147039093" target="_blank" rel="noopener">回答2</a>。</p><p>​    但是，即便是加上这个优化，也仅仅从 40 到了 50，并没有满足我们的要求。</p><p>​    考虑一个可行性剪枝，也就是考虑当前剩余步数不足以到达终点时，直接跳出，也就可以AC了</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dx[] = &#123; <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span> &#125;, dy[] = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> n, m, t, sa, sb, ea, eb, ans;</span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"><span class="keyword">bool</span> okk[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> cur)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == ea &amp;&amp; y == eb &amp;&amp; cur == <span class="number">0</span>)</span><br><span class="line">        ans++;</span><br><span class="line">    <span class="keyword">if</span> (!cur || <span class="built_in">abs</span>(ea - x) + <span class="built_in">abs</span>(eb - y) &gt; cur)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> xx = dx[i] + x, yy = dy[i] + y;</span><br><span class="line">        <span class="keyword">if</span> (okk[xx][yy])</span><br><span class="line">            dfs(xx, yy, cur - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; ch;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">'.'</span> &amp;&amp; ((i - <span class="number">1</span>) | (n - i) | (j - <span class="number">1</span>) | (m - j)) &gt;= <span class="number">0</span>)</span><br><span class="line">                okk[i][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; sa &gt;&gt; sb &gt;&gt; ea &gt;&gt; eb;</span><br><span class="line">    dfs(sa, sb, t);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P1535&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原题链接&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerl
      
    
    </summary>
    
    
      <category term="题解" scheme="http://answerend42.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="深度优先搜索dfs" scheme="http://answerend42.github.io/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2dfs/"/>
    
      <category term="剪枝" scheme="http://answerend42.github.io/tags/%E5%89%AA%E6%9E%9D/"/>
    
  </entry>
  
  <entry>
    <title>Aha-Round-1</title>
    <link href="http://answerend42.github.io/2020/08/18/Aha-Round-1/"/>
    <id>http://answerend42.github.io/2020/08/18/Aha-Round-1/</id>
    <published>2020-08-17T16:33:39.000Z</published>
    <updated>2020-10-03T09:54:08.322Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>团队要走的路还很远啊……</p></blockquote><a id="more"></a><h2 id="Pj"><a href="#Pj" class="headerlink" title="Pj"></a>Pj</h2><h3 id="T1-IOI-AKer"><a href="#T1-IOI-AKer" class="headerlink" title="T1 IOI AKer"></a>T1 <a href="https://www.luogu.com.cn/problem/T143359" target="_blank" rel="noopener">IOI AKer</a></h3><p>​    本场签到题，AC 占比 $\dfrac{13}{16}$ </p><p>​    很简单的字符串模拟</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    getline(<span class="built_in">cin</span>,s);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s;</span><br><span class="line">    <span class="keyword">if</span>(s==<span class="string">"dbxxx"</span>||s==<span class="string">"DBXXX"</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">" csl /weak"</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">" AK IOI! /strong"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="T2-清理收藏夹"><a href="#T2-清理收藏夹" class="headerlink" title="T2 清理收藏夹"></a>T2 <a href="https://www.luogu.com.cn/problem/T143360" target="_blank" rel="noopener">清理收藏夹</a></h3><p>​    很繁琐，赛时最高 14，最低 4 分，得分占比 $\dfrac{3}{16}$</p><p>​    先来吐槽一下题面，看上去很花，很大程度上让人不太想开这道题，细节也颇多，作为 pjT2 是彻底失败的。但是出题人 dbxxx 还是下了很大力气的。</p><h3 id="T3-巧克力机器"><a href="#T3-巧克力机器" class="headerlink" title="T3 巧克力机器"></a>T3 <a href="https://www.luogu.com.cn/problem/T143361" target="_blank" rel="noopener">巧克力机器</a></h3><p>​    有趣的区间 $\text{DP}$,比赛没来得及做。</p><h3 id="T4-加工伸缩门"><a href="#T4-加工伸缩门" class="headerlink" title="T4 加工伸缩门"></a>T4 <a href="https://www.luogu.com.cn/problem/T143362" target="_blank" rel="noopener">加工伸缩门</a></h3><p>​    组合数学神仙题，建议膜拜出题人：dbxxx</p><p><a href="https://www.luogu.com.cn/paste/pmgqz97r" target="_blank" rel="noopener">Pj题解</a>。</p><h2 id="Tg"><a href="#Tg" class="headerlink" title="Tg"></a>Tg</h2><h3 id="T1-function"><a href="#T1-function" class="headerlink" title="T1 function"></a>T1 <a href="https://www.luogu.com.cn/problem/T143365" target="_blank" rel="noopener">function</a></h3><p>​    有趣的数学题，数据范围对于这种题是没有意义的，所以直接上 python，不打高精了。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s=input()</span><br><span class="line">a=int(s.split(<span class="string">" "</span>)[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">if</span>(a%<span class="number">3</span>!=<span class="number">0</span>) :</span><br><span class="line">    print(<span class="string">"Aha"</span>)</span><br><span class="line"><span class="keyword">else</span> :</span><br><span class="line">    print(a//<span class="number">3</span>,<span class="string">""</span>,end=<span class="string">""</span>)</span><br><span class="line">    print(a//<span class="number">3</span>,<span class="string">""</span>,end=<span class="string">""</span>)</span><br><span class="line">    print(a//<span class="number">3</span>+a-a//<span class="number">3</span>*<span class="number">3</span>,end=<span class="string">""</span>)</span><br></pre></td></tr></table></figure><h3 id="T2-￥"><a href="#T2-￥" class="headerlink" title="T2 ￥"></a>T2 <a href="https://www.luogu.com.cn/problem/T143364" target="_blank" rel="noopener">￥</a></h3><p>​    状压 $\text{DP}$,不会（</p><h3 id="T3-绝世唐门"><a href="#T3-绝世唐门" class="headerlink" title="T3 绝世唐门"></a>T3 <a href="https://www.luogu.com.cn/problem/T143363" target="_blank" rel="noopener">绝世唐门</a></h3><p>​    毒瘤图论，不过用到的算法不太复杂。</p><p><a href="https://www.luogu.com.cn/paste/cqsgmh8g" target="_blank" rel="noopener">Tg题解</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    大家的参赛热情都很高，题目质量也很好，一些关键的细节把握不到位，作为一个新生团队，已经是很不错的水平了。</p><blockquote><p>Gar：多练可破。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;团队要走的路还很远啊……&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="比赛" scheme="http://answerend42.github.io/categories/%E6%AF%94%E8%B5%9B/"/>
    
    
      <category term="字符串" scheme="http://answerend42.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="模拟" scheme="http://answerend42.github.io/tags/%E6%A8%A1%E6%8B%9F/"/>
    
      <category term="动态规划" scheme="http://answerend42.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="区间DP" scheme="http://answerend42.github.io/tags/%E5%8C%BA%E9%97%B4DP/"/>
    
      <category term="状压DP" scheme="http://answerend42.github.io/tags/%E7%8A%B6%E5%8E%8BDP/"/>
    
      <category term="数论" scheme="http://answerend42.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="高精度" scheme="http://answerend42.github.io/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"/>
    
      <category term="最小生成树" scheme="http://answerend42.github.io/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
      <category term="图论" scheme="http://answerend42.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="广度优先搜索bfs" scheme="http://answerend42.github.io/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2bfs/"/>
    
  </entry>
  
  <entry>
    <title>暑假线下集训总结</title>
    <link href="http://answerend42.github.io/2020/08/01/%E6%9A%91%E5%81%87%E7%BA%BF%E4%B8%8B%E9%9B%86%E8%AE%AD%E6%80%BB%E7%BB%93/"/>
    <id>http://answerend42.github.io/2020/08/01/%E6%9A%91%E5%81%87%E7%BA%BF%E4%B8%8B%E9%9B%86%E8%AE%AD%E6%80%BB%E7%BB%93/</id>
    <published>2020-07-31T16:10:30.000Z</published>
    <updated>2020-08-01T01:59:23.351Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    中考完第二天就开始了集训，说实话，是既兴奋又紧张。一切似乎都是新的，让第二次来的我充满新鲜感（<del>第一天不知道机房位置，还是跟着同学去的</del>）。</p><a id="more"></a><h2 id="集训中的感想"><a href="#集训中的感想" class="headerlink" title="集训中的感想"></a>集训中的感想</h2><p>​    身边都是很优秀的同龄人，在一起刷题感到很有斗志，果然在学校刷题和在家里刷题是完全不同的。</p><h2 id="部分题目总结"><a href="#部分题目总结" class="headerlink" title="部分题目总结"></a>部分题目总结</h2><h3 id="真题练习（2020-7-22）"><a href="#真题练习（2020-7-22）" class="headerlink" title="真题练习（2020.7.22）"></a>真题练习（2020.7.22）</h3><ul><li><p><a href="https://www.luogu.com.cn/problemnew/show/P1563" target="_blank" rel="noopener"><strong>P1563</strong> 玩具谜题</a></p></li><li><p><a href="https://www.luogu.com.cn/problemnew/show/P2615" target="_blank" rel="noopener"><strong>P2615</strong> 神奇的幻方</a></p></li><li><p><a href="https://www.luogu.com.cn/problemnew/show/P3958" target="_blank" rel="noopener"><strong>P3958</strong> 奶酪</a></p></li><li><p><a href="https://www.luogu.com.cn/problemnew/show/P1328" target="_blank" rel="noopener"><strong>P1328</strong> 生活大爆炸版石头剪刀布</a></p></li><li><p><a href="https://www.luogu.com.cn/problemnew/show/P2822" target="_blank" rel="noopener"><strong>P2822</strong> 组合数问题</a></p><p>这五道题是第一天的练手题，也是历年的真题，难度在接受范围以内，我之前除第五题都做过。</p><p>第五题还没有做，先 gugugu</p></li></ul><h3 id="单调队列（2020-7-22）"><a href="#单调队列（2020-7-22）" class="headerlink" title="单调队列（2020.7.22）"></a>单调队列（2020.7.22）</h3><ul><li><p><a href="https://www.luogu.com.cn/problemnew/show/P1440" target="_blank" rel="noopener"><strong>P1440</strong> 求m区间内的最小值</a></p></li><li><p><a href="https://www.luogu.com.cn/problemnew/show/P1886" target="_blank" rel="noopener"><strong>P1886</strong> 滑动窗口 /【模板】单调队列</a></p></li><li><p><a href="https://www.luogu.com.cn/problemnew/show/P3088" target="_blank" rel="noopener"><strong>P3088</strong>  [USACO13NOV]Crowded Cows S</a></p></li><li><p><a href="https://www.luogu.com.cn/problemnew/show/P1725" target="_blank" rel="noopener"><strong>P1725</strong> 琪露诺</a></p></li><li><p><a href="https://www.luogu.com.cn/problemnew/show/U88745" target="_blank" rel="noopener"><strong>U88745</strong> 最大子序和</a></p></li><li><p><a href="https://www.luogu.com.cn/problemnew/show/U88746" target="_blank" rel="noopener"><strong>U88746</strong> 烽火传递</a></p><p>这六题是第一天所讲的单调队列题目，其中有版子题，也有根据单调队列优化 dp 的内容。我还不大会优化 dp，先放出模板题的代码。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2</span>*<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n,m; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> val,pos;</span><br><span class="line">&#125;e[N];</span><br><span class="line"><span class="built_in">deque</span>&lt;Node&gt; q;</span><br><span class="line"><span class="keyword">int</span> ans[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;e[i].val);</span><br><span class="line">e[i].pos=i<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">ans[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="comment">//保证是个队列 且保证单调性 </span></span><br><span class="line">        <span class="keyword">while</span>(!q.empty()&amp;&amp;q.back().val&gt;e[i].val)</span><br><span class="line">q.pop_back();</span><br><span class="line"><span class="comment">//新元素入队 </span></span><br><span class="line">q.push_back(e[i]);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()&amp;&amp;q.front().pos&lt;i-m)</span><br><span class="line">            q.pop_front();</span><br><span class="line">        ans[i]=q.front().val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="字符串问题（2020-7-23）"><a href="#字符串问题（2020-7-23）" class="headerlink" title="字符串问题（2020.7.23）"></a>字符串问题（2020.7.23）</h3><ul><li><p><a href="https://www.luogu.com.cn/problemnew/show/P3375" target="_blank" rel="noopener"><strong>P3375</strong> 【模板】KMP字符串匹配</a></p></li><li><p><a href="https://www.luogu.com.cn/problemnew/show/P2375" target="_blank" rel="noopener"><strong>P2375</strong> [NOI2014]动物园</a></p></li><li><p><a href="https://www.luogu.com.cn/problemnew/show/P2580" target="_blank" rel="noopener"><strong>P2580</strong> 于是他错误的点名开始了</a></p></li><li><p><a href="https://www.luogu.com.cn/problemnew/show/P2292" target="_blank" rel="noopener"><strong>P2292</strong> [HNOI2004]L语言</a></p></li><li><p><a href="https://www.luogu.com.cn/problemnew/show/P3808" target="_blank" rel="noopener"><strong>P3808</strong> 【模板】AC自动机（简单版）</a></p></li><li><p><a href="https://www.luogu.com.cn/problemnew/show/U88779" target="_blank" rel="noopener"><strong>U88779</strong> keywords search</a></p></li><li><p><a href="https://www.luogu.com.cn/problemnew/show/P3796" target="_blank" rel="noopener"><strong>P3796</strong> 【模板】AC自动机（加强版）</a></p></li><li><p><a href="https://www.luogu.com.cn/problemnew/show/P2414" target="_blank" rel="noopener"><strong>P2414</strong> [NOI2011]阿狸的打字机</a></p></li><li><p><a href="https://www.luogu.com.cn/problemnew/show/CF1200E" target="_blank" rel="noopener"><strong>CF1200E</strong> Compress Words</a></p></li><li><p><a href="https://www.luogu.com.cn/problemnew/show/P4824" target="_blank" rel="noopener"><strong>P4824</strong> [USACO15FEB]Censoring S</a></p></li><li><p><a href="https://www.luogu.com.cn/problemnew/show/P3435" target="_blank" rel="noopener"><strong>P3435</strong> [POI2006]OKR-Periods of Words</a></p></li><li><p><a href="https://www.luogu.com.cn/problemnew/show/P3121" target="_blank" rel="noopener"><strong>P3121</strong> [USACO15FEB]Censoring G</a></p></li><li><p><a href="https://www.luogu.com.cn/problemnew/show/P3966" target="_blank" rel="noopener"><strong>P3966</strong> [TJOI2013]单词</a></p></li><li><p><a href="https://www.luogu.com.cn/problemnew/show/P3041" target="_blank" rel="noopener"><strong>P3041</strong> [USACO12JAN]Video Game G</a></p></li><li><p><a href="https://www.luogu.com.cn/problemnew/show/P3311" target="_blank" rel="noopener"><strong>P3311</strong> [SDOI2014] 数数</a></p></li><li><p><a href="https://www.luogu.com.cn/problemnew/show/P4052" target="_blank" rel="noopener"><strong>P4052</strong> [JSOI2007]文本生成器</a></p><p>大都不会做，可以说是找到软肋了。</p></li></ul><h3 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h3><ul><li><p><a href="https://www.luogu.com.cn/problemnew/show/P3374" target="_blank" rel="noopener"><strong>P3374</strong> 【模板】树状数组 1</a></p></li><li><p><a href="https://www.luogu.com.cn/problemnew/show/P2068" target="_blank" rel="noopener"><strong>P2068</strong> 统计和</a></p></li><li><p><a href="https://www.luogu.com.cn/problemnew/show/U88769" target="_blank" rel="noopener"><strong>U88769</strong> 数列操作</a></p></li><li><p><a href="https://www.luogu.com.cn/problemnew/show/P3368" target="_blank" rel="noopener"><strong>P3368</strong> 【模板】树状数组 2</a></p></li><li><p><a href="https://www.luogu.com.cn/problemnew/show/P1966" target="_blank" rel="noopener"><strong>P1966</strong> 火柴排队</a></p></li><li><p><a href="https://www.luogu.com.cn/problemnew/show/P1637" target="_blank" rel="noopener"><strong>P1637</strong> 三元上升子序列</a></p></li><li><p><a href="https://www.luogu.com.cn/problemnew/show/P1774" target="_blank" rel="noopener"><strong>P1774</strong> 最接近神的人</a></p><p>除了三元上升子序列全部都做完了，三元上升子序列只打了暴力。</p><p>给出树状数组知道的使用方法</p><p>单点查询 区间查询 单点修改 区间修改</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x&amp;-x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;x&lt;=n;x+=lowbit(x))</span><br><span class="line">        t[x]+=k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//单点加上 k</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;x;x-=x&amp;-x)</span><br><span class="line">        ans+=t[x];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//单点查询</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对于区间修改，我们可以使用差分来完成</span></span><br><span class="line"><span class="comment">//add(x,a[i]-a[i-1])</span></span><br><span class="line"><span class="comment">//此时将 l~r 全部加上 k 只需</span></span><br><span class="line"><span class="comment">//add(x,k) add(y-1,-k)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对于区间查询，我们可以使用前缀和来完成</span></span><br><span class="line"><span class="comment">//ask(r)-ask(l-1)</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Nauuo-的模拟赛（2020-7-24）"><a href="#Nauuo-的模拟赛（2020-7-24）" class="headerlink" title="Nauuo 的模拟赛（2020.7.24）"></a>Nauuo 的模拟赛（2020.7.24）</h3><p> <a href="https://www.luogu.com.cn/problemnew/show/P4964" target="_blank" rel="noopener"><strong>P4964</strong> 绫小路的特别考试</a></p><p>​    这就是要补的题了</p><h3 id="manacher（2020-7-27）"><a href="#manacher（2020-7-27）" class="headerlink" title="manacher（2020.7.27）"></a>manacher（2020.7.27）</h3><ul><li><p><a href="https://www.luogu.com.cn/problemnew/show/P3805" target="_blank" rel="noopener"><strong>P3805</strong> 【模板】manacher算法</a></p></li><li><p><a href="https://www.luogu.com.cn/problemnew/show/P1659" target="_blank" rel="noopener"><strong>P1659</strong> [国家集训队]拉拉队排练</a></p></li><li><p><a href="https://www.luogu.com.cn/problemnew/show/P4555" target="_blank" rel="noopener"><strong>P4555</strong> [国家集训队]最长双回文串</a></p><p>最长双回文子串要补。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;​    中考完第二天就开始了集训，说实话，是既兴奋又紧张。一切似乎都是新的，让第二次来的我充满新鲜感（&lt;del&gt;第一天不知道机房位置，还是跟着同学去的&lt;/del&gt;）。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>2月flag汇总</title>
    <link href="http://answerend42.github.io/2020/05/01/2%E6%9C%88flag%E6%B1%87%E6%80%BB/2%E6%9C%88flag%E6%B1%87%E6%80%BB/"/>
    <id>http://answerend42.github.io/2020/05/01/2%E6%9C%88flag%E6%B1%87%E6%80%BB/2%E6%9C%88flag%E6%B1%87%E6%80%BB/</id>
    <published>2020-04-30T16:08:45.000Z</published>
    <updated>2020-07-27T12:44:08.741Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><del>精彩打脸合集</del></p></blockquote><a id="more"></a><blockquote><p><a href="https://www.luogu.com.cn/problem/P3133" target="_blank" rel="noopener">P3133 [USACO16JAN]Radio Contact G</a></p><p>一道DP，不会推式子，以后要复习</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">f[i][j] 表示 FJ 第 i 步，BS 第 j 步时的最小花费</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">可以从以下三种情况转移过来</span></span><br><span class="line"><span class="comment">1. FJ 不动 BS 动</span></span><br><span class="line"><span class="comment">2. FJ 动 BS 不动</span></span><br><span class="line"><span class="comment">3. FJ 不动 BS 不动</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">f[i][j]=min(f[i-1][j],min(f[i][j-1],f[i-1][j-1]))+dis(i,j);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">&#125;fj[<span class="number">1005</span>],bs[<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,f[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dis</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (fj[i].x-bs[j].x)*(fj[i].x-bs[j].x)+(fj[i].y-bs[j].y)*(fj[i].y-bs[j].y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d%d"</span>,&amp;n,&amp;m,&amp;fj[<span class="number">0</span>].x,&amp;fj[<span class="number">0</span>].y,&amp;bs[<span class="number">0</span>].x,&amp;bs[<span class="number">0</span>].y);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> c;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;c;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">'N'</span>)</span><br><span class="line">            fj[i].y=fj[i<span class="number">-1</span>].y+<span class="number">1</span>,fj[i].x=fj[i<span class="number">-1</span>].x;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">'S'</span>)</span><br><span class="line">            fj[i].y=fj[i<span class="number">-1</span>].y<span class="number">-1</span>,fj[i].x=fj[i<span class="number">-1</span>].x;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">'W'</span>)</span><br><span class="line">            fj[i].y=fj[i<span class="number">-1</span>].y,fj[i].x=fj[i<span class="number">-1</span>].x<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">'E'</span>)</span><br><span class="line">            fj[i].y=fj[i<span class="number">-1</span>].y,fj[i].x=fj[i<span class="number">-1</span>].x+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> c;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;c;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">'N'</span>)</span><br><span class="line">            bs[i].y=bs[i<span class="number">-1</span>].y+<span class="number">1</span>,bs[i].x=bs[i<span class="number">-1</span>].x;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">'S'</span>)</span><br><span class="line">            bs[i].y=bs[i<span class="number">-1</span>].y<span class="number">-1</span>,bs[i].x=bs[i<span class="number">-1</span>].x;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">'W'</span>)</span><br><span class="line">            bs[i].y=bs[i<span class="number">-1</span>].y,bs[i].x=bs[i<span class="number">-1</span>].x<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">'E'</span>)</span><br><span class="line">            bs[i].y=bs[i<span class="number">-1</span>].y,bs[i].x=bs[i<span class="number">-1</span>].x+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) f[i][<span class="number">0</span>]=f[i<span class="number">-1</span>][<span class="number">0</span>]+dis(i,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) f[<span class="number">0</span>][i]=f[<span class="number">0</span>][i<span class="number">-1</span>]+dis(<span class="number">0</span>,i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            f[i][j]=min(f[i<span class="number">-1</span>][j],min(f[i][j<span class="number">-1</span>],f[i<span class="number">-1</span>][j<span class="number">-1</span>]))+dis(i,j);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,f[n][m]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://www.luogu.com.cn/problem/P4779" target="_blank" rel="noopener">P4779 【模板】单源最短路径（标准版）</a></p><p>复习了dijkstra，还是不熟，多次WA</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100005</span>,M = N*<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> dis[N],book[N],first[N],nxt[M],v[M],w[M],idx,n,m,s,x,y,z;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">    v[++idx]=y;</span><br><span class="line">    w[idx]=z;</span><br><span class="line">    nxt[idx]=first[x];</span><br><span class="line">    first[x]=idx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dij</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) dis[i]=<span class="number">1e10</span>;</span><br><span class="line">    priority_queue&lt;PII&gt; q;</span><br><span class="line">    dis[s]=<span class="number">0</span>;</span><br><span class="line">    q.push(mp(<span class="number">0</span>,s));</span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> t=q.top().se;</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">if</span>(book[t]) <span class="keyword">continue</span>;</span><br><span class="line">        book[t]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=first[t];i;i=nxt[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(dis[t]+w[i]&lt;dis[v[i]]) &#123;</span><br><span class="line">                dis[v[i]]=dis[t]+w[i];</span><br><span class="line">                q.push(mp(-dis[v[i]],v[i]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//17行挺好打的</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)  &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">        add(x,y,z);</span><br><span class="line">    &#125;</span><br><span class="line">    dij();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>,dis[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://www.luogu.com.cn/problem/P2015" target="_blank" rel="noopener">P2015 二叉苹果树</a></p><p>AC了但确实不会，要复习</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">f[u][j] 表示以 u 为子树根节点保留 j 条边时的最大苹果数</span></span><br><span class="line"><span class="comment">son[u][0] 表示 u 的左儿子，son[u][1] 表示 u 的右儿子</span></span><br><span class="line"><span class="comment">apple[u][0] 表示 u与 u 的左儿子连边的苹果数，apple[u][1] 表示 u与 u 的右儿子连边的苹果数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">用 k 表示保留给以 u 为根节点的子树中分配给 u 的左节点能够保留的边</span></span><br><span class="line"><span class="comment">1. k==0，干掉左子树，探寻右子树的情况</span></span><br><span class="line"><span class="comment">2. k==j，干掉右子树，探寻左子树的情况</span></span><br><span class="line"><span class="comment">3. k&gt;0&amp;&amp;k&lt;j，给左子树 k 条边，右子树 j-k 条边</span></span><br><span class="line"><span class="comment">（实际上如果要保留一棵子树就必定与根节点连有边，所以边的数量-1）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. f[u][j]=max(f[u][j],f[son[u][1]][j-1]+apple[u][1]);</span></span><br><span class="line"><span class="comment">2. f[u][j]=max(f[u][j],f[son[u][0]][j-1]+apple[u][0]);</span></span><br><span class="line"><span class="comment">3. f[u][j]=max(f[u][j],f[son[u][0]][k-1]+apple[u][0]+f[son[u][1]][j-k-1]+apple[u][1]);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">    1. 边权转点权</span></span><br><span class="line"><span class="comment">    2. 树形DP</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">105</span>,M=N*<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> n,q,idx;</span><br><span class="line"><span class="keyword">int</span> first[N],nxt[M],v[M],w[M];</span><br><span class="line"><span class="keyword">int</span> son[N][<span class="number">2</span>],apple[N][<span class="number">2</span>],f[N][N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">    v[++idx]=y;</span><br><span class="line">    w[idx]=z;</span><br><span class="line">    nxt[idx]=first[x];</span><br><span class="line">    first[x]=idx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> father)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> idx2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=first[u];i;i=nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(v[i]!=father) &#123;</span><br><span class="line">            son[u][idx2]=v[i];<span class="comment">//找儿子</span></span><br><span class="line">            apple[u][idx2]=w[i];<span class="comment">//苹果个数</span></span><br><span class="line">            idx2++;</span><br><span class="line">            dfs(v[i],u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=q;j++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=j;k++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(k==<span class="number">0</span>)</span><br><span class="line">                f[u][j]=max(f[u][j],f[son[u][<span class="number">1</span>]][j<span class="number">-1</span>]+apple[u][<span class="number">1</span>]);</span><br><span class="line">            <span class="comment">//1个都不留的情况，由于本身与根节点有一条边，另一个只能是j-1</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(k==j)</span><br><span class="line">                f[u][j]=max(f[u][j],f[son[u][<span class="number">0</span>]][j<span class="number">-1</span>]+apple[u][<span class="number">0</span>]);</span><br><span class="line">            <span class="comment">//all in</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            f[u][j]=max(f[u][j],f[son[u][<span class="number">0</span>]][k<span class="number">-1</span>]+apple[u][<span class="number">0</span>]+f[son[u][<span class="number">1</span>]][j-k<span class="number">-1</span>]+apple[u][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x,y,z;i&lt;n;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">        add(x,y,z);</span><br><span class="line">        add(y,x,z);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,f[<span class="number">1</span>][q]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;del&gt;精彩打脸合集&lt;/del&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="记录" scheme="http://answerend42.github.io/categories/%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Codeforces Round 636 (Div. 3)</title>
    <link href="http://answerend42.github.io/2020/04/26/cf/Codeforces%20Round%20636%20(Div.%203)/"/>
    <id>http://answerend42.github.io/2020/04/26/cf/Codeforces%20Round%20636%20(Div.%203)/</id>
    <published>2020-04-26T09:27:30.000Z</published>
    <updated>2020-08-04T15:44:34.616Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>日常三题选手…</p><p><img src="https://cdn.jsdelivr.net/gh/BoringHacker/cdn/emojis/majsoul/maj-38.png" alt=""></p></blockquote><a id="more"></a><h2 id="A-Candies"><a href="#A-Candies" class="headerlink" title="A. Candies"></a><a href="https://codeforces.com/contest/1343/problem/A" target="_blank" rel="noopener">A. Candies</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个整数 $n$，$k$ 为大于 $1$ 的任意整数，求解方程 $x + 2x + 4x + \dots + 2^{k-1} x = n$。</p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>可以计算得出实质上在求 $(2^{k}-1)x=n$，枚举一下 $2^k-1$，对于 $n \mid 2^k-1$，输出 $x=\dfrac{n}{2^k-1}$。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> _,n;</span><br><span class="line">ll idx[<span class="number">10005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    idx[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">63</span>;i++) idx[i]=<span class="built_in">pow</span>(<span class="number">2</span>,i)<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;_);_;_--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">63</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(n%idx[i]==<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,n/idx[i]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-Balanced-Array"><a href="#B-Balanced-Array" class="headerlink" title="B. Balanced Array"></a><a href="https://codeforces.com/contest/1343/problem/B" target="_blank" rel="noopener">B. Balanced Array</a></h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个正整数 $n(n \mid 2)$，构造一个长度为 $n$ 的数组 $a$ 使得 $a$ 的前半部分之和与后半部分之和相等，同时 $a$ 的前半部分都是偶数，后半部分都是奇数，$a$ 中每一个数都不相等。</p><h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><p>首先思考最小的部分（常用套路），发现 $n=2$ 一定无解，$n=4$ 一定有解。观察样例提示可以发现对于任意 $n \mid 4$ 都是有解的，其他则一定无解。构造方式也比较套路，对于 $1 \sim \dfrac{n}{2}$,<script type="math/tex">a_i = 2^i</script>,对于 $\dfrac{n}{2}+1 \sim n $ , $a_i=a_ { i - \frac{n}{2} } - 1 $ ,再对最后一个数处理一下  $a_n \gets a_n+\dfrac{n}{2} $，就成功的构造出来了。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> _,a[<span class="number">200005</span>],n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;_);_;_--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">4</span>!=<span class="number">0</span>) <span class="built_in">puts</span>(<span class="string">"NO"</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"YES"</span>);</span><br><span class="line">            <span class="keyword">int</span> idx=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i+=<span class="number">2</span>) &#123;</span><br><span class="line">                a[++idx]=i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n/<span class="number">2</span><span class="number">-1</span>;i++) &#123;</span><br><span class="line">                idx++;</span><br><span class="line">                a[idx]=a[idx-n/<span class="number">2</span>]<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            idx++;</span><br><span class="line">            a[idx]=a[idx-n/<span class="number">2</span>]+n/<span class="number">2</span><span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>,a[i]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Alternating-Subsequence"><a href="#C-Alternating-Subsequence" class="headerlink" title="C. Alternating Subsequence"></a><a href="https://codeforces.com/contest/1343/problem/C" target="_blank" rel="noopener">C. Alternating Subsequence</a></h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定长度为 $n$ 的序列 $a$，要求求出最长的一正一负的 $a$ 的子序列中的最大和。</p><h3 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h3><p>题目要求了最长，可以直接每一段连续区间中只取一个最大的，保证最终和最大。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//https://codeforces.com/contest/1343/problem/C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> _,n,a[<span class="number">200005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;_);_;_--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">1</span>,maxx,minx;</span><br><span class="line">        ll sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i!=n+<span class="number">1</span>) &#123;</span><br><span class="line">            maxx=<span class="number">-0x3f3f3f3f</span>;</span><br><span class="line">            minx=<span class="number">-0x3f3f3f3f</span>;</span><br><span class="line">            <span class="keyword">while</span>(a[i]&gt;<span class="number">0</span>&amp;&amp;i!=n+<span class="number">1</span>) &#123;</span><br><span class="line">                maxx=max(maxx,a[i]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(a[i<span class="number">-1</span>]&gt;<span class="number">0</span>) sum+=maxx;</span><br><span class="line">            <span class="keyword">while</span>(a[i]&lt;<span class="number">0</span>&amp;&amp;i!=n+<span class="number">1</span>) &#123;</span><br><span class="line">                minx=max(minx,a[i]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(a[i<span class="number">-1</span>]&lt;<span class="number">0</span>) sum+=minx;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D-Constant-Palindrome-Sum"><a href="#D-Constant-Palindrome-Sum" class="headerlink" title="D. Constant Palindrome Sum"></a><a href="https://codeforces.com/contest/1343/problem/D" target="_blank" rel="noopener">D. Constant Palindrome Sum</a></h2><p>题目太神仙了，赛后看题解搞出来了，一时半会也不知道怎么做。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;日常三题选手…&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/BoringHacker/cdn/emojis/majsoul/maj-38.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="比赛" scheme="http://answerend42.github.io/categories/%E6%AF%94%E8%B5%9B/"/>
    
    
      <category term="模拟" scheme="http://answerend42.github.io/tags/%E6%A8%A1%E6%8B%9F/"/>
    
      <category term="贪心" scheme="http://answerend42.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="构造" scheme="http://answerend42.github.io/tags/%E6%9E%84%E9%80%A0/"/>
    
      <category term="数学" scheme="http://answerend42.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces Round 635 (Div. 2)</title>
    <link href="http://answerend42.github.io/2020/04/24/cf/Codeforces%20Round%20635%20(Div.%202)/"/>
    <id>http://answerend42.github.io/2020/04/24/cf/Codeforces%20Round%20635%20(Div.%202)/</id>
    <published>2020-04-24T13:13:19.000Z</published>
    <updated>2020-04-24T13:16:10.878Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>中国场！莫名的激动。题目的风格真的和出题人有关，<del>虽然我只做了三题</del></p></blockquote><a id="more"></a><h2 id="A-Ichihime-and-Triangle"><a href="#A-Ichihime-and-Triangle" class="headerlink" title="A. Ichihime and Triangle"></a><a href="https://codeforces.ml/contest/1337/problem/A" target="_blank" rel="noopener">A. Ichihime and Triangle</a></h2><h3 id="题意描述"><a href="#题意描述" class="headerlink" title="题意描述"></a>题意描述</h3><p>给定 $a,b,c,d$ 其中 $a \le b \le c \le d$，试找到 $x,y,z$ 其中 </p><ul><li>$a \leq x \leq b$</li><li>$b \leq y \leq c$</li><li>$c \leq z \leq d$</li></ul><p>使得以 $x,y,z$ 为三角形三边长度构成一个三角形。</p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>一开始的朴素思路是</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//https://codeforces.ml/contest/1337/problem/0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> _,a[<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;_);_;_--) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++)<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">        <span class="keyword">if</span>(a[<span class="number">1</span>]+a[<span class="number">2</span>]&lt;=a[<span class="number">3</span>]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[<span class="number">3</span>]-a[<span class="number">2</span>]&lt;=a[<span class="number">2</span>]) <span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>,a[<span class="number">3</span>]-a[<span class="number">2</span>]+<span class="number">1</span>,a[<span class="number">2</span>],a[<span class="number">3</span>]);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>,a[<span class="number">1</span>],a[<span class="number">3</span>]-a[<span class="number">1</span>]+<span class="number">1</span>,a[<span class="number">3</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>,a[<span class="number">1</span>],a[<span class="number">2</span>],a[<span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是 $x,y,z \le 5\times 10^8$ 。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//https://codeforces.ml/contest/1337/problem/0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> _,a[<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;_);_;_--) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++)<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>,a[<span class="number">2</span>],a[<span class="number">3</span>],a[<span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造一组腰长大于边长的等腰三角形就好了。</p><h2 id="B-Kana-and-Dragon-Quest-game"><a href="#B-Kana-and-Dragon-Quest-game" class="headerlink" title="B. Kana and Dragon Quest game"></a><a href="https://codeforces.ml/contest/1337/problem/B" target="_blank" rel="noopener">B. Kana and Dragon Quest game</a></h2><h3 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h3><p>一个怪物有 $x$ 的血量，你可以执行最多 $n$ 次操作使得其血量等于 $\left\lfloor \frac{x}{2} \right\rfloor + 10$，也可以执行最多 $m$ 次操作使得其血量等于 $x-10$，问能否杀死它。</p><h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><p>想尽办法用第一种方法就行了，再判断剩下的血量能否被击杀</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//https://codeforces.ml/contest/1337/problem/B</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> _,n,m;</span><br><span class="line"><span class="keyword">double</span> x;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;_);_;_--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf%d%d"</span>,&amp;x,&amp;n,&amp;m);</span><br><span class="line">        <span class="keyword">int</span> ansn=<span class="number">0</span>,ansm=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;=m*<span class="number">10</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"YES"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(ansn&lt;n) &#123;</span><br><span class="line">            x=<span class="built_in">floor</span>(x/<span class="number">2</span>)+<span class="number">10</span>;</span><br><span class="line">            ansn++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;=m*<span class="number">10</span>) <span class="built_in">puts</span>(<span class="string">"YES"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"NO"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Linova-and-Kingdom"><a href="#C-Linova-and-Kingdom" class="headerlink" title="C. Linova and Kingdom"></a><a href="https://codeforces.ml/contest/1337/problem/C" target="_blank" rel="noopener">C. Linova and Kingdom</a></h2><h3 id="题意简述-1"><a href="#题意简述-1" class="headerlink" title="题意简述"></a>题意简述</h3><p>给定一棵 $n$ 个节点的树，选择 $k$ 个节点，使得从这些节点出发到根节点经过的非选中的点数量尽可能多，求出最大值。</p><h3 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h3><p>显而易见的选择 $k$ 个深度最深的点就行了。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">2</span>*<span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> idx,v[maxn*<span class="number">2</span>],first[maxn],nxt[maxn*<span class="number">2</span>],x,y,n,k;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    v[++idx]=y;</span><br><span class="line">    nxt[idx]=first[x];</span><br><span class="line">    first[x]=idx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> sz,dep;</span><br><span class="line">&#125; a[maxn];</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a1,node a2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a1.dep-a1.sz&gt;a2.dep-a2.sz;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">a[u].sz=<span class="number">1</span>,a[u].dep=a[fa].dep+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=first[u];i;i=nxt[i])</span><br><span class="line"><span class="keyword">if</span>(v[i]!=fa)</span><br><span class="line">            dfs(v[i],u),a[u].sz+=a[v[i]].sz;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line">    a[<span class="number">0</span>].dep=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y),add(x,y),add(y,x);</span><br><span class="line">dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    sort(a+<span class="number">1</span>,a+n+<span class="number">1</span>,cmp);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++) ans+=a[i].dep-a[i].sz;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D-Xenia-and-Colorful-Gems"><a href="#D-Xenia-and-Colorful-Gems" class="headerlink" title="D. Xenia and Colorful Gems"></a><a href="https://codeforces.ml/contest/1337/problem/D" target="_blank" rel="noopener">D. Xenia and Colorful Gems</a></h2><p>题目太神仙了，先gugugu</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;中国场！莫名的激动。题目的风格真的和出题人有关，&lt;del&gt;虽然我只做了三题&lt;/del&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="比赛" scheme="http://answerend42.github.io/categories/%E6%AF%94%E8%B5%9B/"/>
    
    
      <category term="模拟" scheme="http://answerend42.github.io/tags/%E6%A8%A1%E6%8B%9F/"/>
    
      <category term="贪心" scheme="http://answerend42.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="构造" scheme="http://answerend42.github.io/tags/%E6%9E%84%E9%80%A0/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces Round 633 (Div. 2)</title>
    <link href="http://answerend42.github.io/2020/04/24/cf/Codeforces%20Round%20633%20(Div.%202)/"/>
    <id>http://answerend42.github.io/2020/04/24/cf/Codeforces%20Round%20633%20(Div.%202)/</id>
    <published>2020-04-24T10:38:15.000Z</published>
    <updated>2020-08-04T15:51:58.840Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>可能是到目前为止最成功的一次 cf 了，下次要做到没人带我也这么强。</p></blockquote><a id="more"></a><h2 id="A-Filling-Diamonds"><a href="#A-Filling-Diamonds" class="headerlink" title="A. Filling Diamonds"></a><a href="https://codeforces.com/contest/1339/problem/A" target="_blank" rel="noopener">A. Filling Diamonds</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定形如下图的形状，问用形如 $n=1$ 时的图形完全填充的方案数。</p><p><img src="https://www.superbed.cn/item/5ea265a9c2a9a83be51bb2bf.png" alt=""></p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>模拟发现每种方案有且仅有一个竖着摆放的形状，答案即为 $n$ 。</p><p><img src="https://www.superbed.cn/item/5ea265aac2a9a83be51bb428.png" alt=""></p><p>代码</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> _,n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;_);_;_--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-Sorted-Adjacent-Differences"><a href="#B-Sorted-Adjacent-Differences" class="headerlink" title="B. Sorted Adjacent Differences"></a><a href="https://codeforces.com/contest/1339/problem/B" target="_blank" rel="noopener">B. Sorted Adjacent Differences</a></h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定数组 $a$  要求重排使得 <script type="math/tex">|a_1 - a_2| \le |a_2 - a_3| \le \ldots \le |a_{n-1} - a_n|</script>。</p><h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><p>最大的和最小的放一起，产生的差当然是最大的，直接放到最后，接着是次大值和次小值。</p><p><img src="https://pic.downk.cc/item/5ea2b795c2a9a83be58337f6.gif" alt=""></p><p>推一下就知道每个元素最后的位置是什么了，可以按照官方题解所说的确定中间位置之后一左一右就可以了。</p><p>代码</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> _,n,a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;_);_;_--) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">sort(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> m=(n+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,a[m]);</span><br><span class="line">            m+=i&amp;<span class="number">1</span>?i:-i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Powered-Addition"><a href="#C-Powered-Addition" class="headerlink" title="C. Powered Addition"></a><a href="https://codeforces.com/contest/1339/problem/C" target="_blank" rel="noopener">C. Powered Addition</a></h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定数组 $a$，可以在第 $x$ 秒给 $a$ 中任意一段连续的数加上 $2^{x-1}$（或者不加），问至少多少秒后使得数组不递减。</p><h3 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h3><p>每次加 $a_i$ 的时候将连续的一段 $a_j \leq a_i (j&gt;i)$ 全部也加上，判断是否不递减</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100005</span>;</span><br><span class="line">ll _,n,a[maxn],maxa,ans,j,k,sum;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;_);_;_--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n);</span><br><span class="line">        k=<span class="number">1</span>,sum=ans=<span class="number">0</span>,maxa=<span class="number">-0x3f3f3f3f</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a[i]);</span><br><span class="line">            <span class="keyword">while</span>(a[i]+sum&lt;maxa) &#123;<span class="comment">//加上 sum 还是不行，只能加更多</span></span><br><span class="line">                sum+=k,ans++;</span><br><span class="line">                <span class="keyword">if</span>(k&lt;=<span class="number">1e10</span><span class="number">-1</span>) k=k&lt;&lt;<span class="number">1</span>;<span class="comment">//k = 2^&#123;x-1&#125;</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            maxa=maxa&gt;a[i]?maxa:a[i];<span class="comment">//更新当前一段已知最大值，之后的必须大于等于 maxa</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D-Edge-Weight-Assignment"><a href="#D-Edge-Weight-Assignment" class="headerlink" title="D. Edge Weight Assignment"></a><a href="https://codeforces.com/contest/1339/problem/D" target="_blank" rel="noopener">D. Edge Weight Assignment</a></h2><p>太神仙了，先gugugu</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次比较明显的感受就是想法全是对的，这是思维得到训练的结果，但是实现起来非常复杂，还搞错了好几次，其实就是练少了。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;可能是到目前为止最成功的一次 cf 了，下次要做到没人带我也这么强。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="比赛" scheme="http://answerend42.github.io/categories/%E6%AF%94%E8%B5%9B/"/>
    
    
      <category term="模拟" scheme="http://answerend42.github.io/tags/%E6%A8%A1%E6%8B%9F/"/>
    
      <category term="构造" scheme="http://answerend42.github.io/tags/%E6%9E%84%E9%80%A0/"/>
    
  </entry>
  
  <entry>
    <title>区间DP的一些理解</title>
    <link href="http://answerend42.github.io/2020/04/17/%E5%8C%BA%E9%97%B4DP%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/%E5%8C%BA%E9%97%B4DP%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/"/>
    <id>http://answerend42.github.io/2020/04/17/%E5%8C%BA%E9%97%B4DP%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/%E5%8C%BA%E9%97%B4DP%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/</id>
    <published>2020-04-17T06:50:18.000Z</published>
    <updated>2020-06-21T09:14:10.220Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>区间$\text{DP}$比线性$\text{DP}$好想一些。</p></blockquote><a id="more"></a><h2 id="合并沙子"><a href="#合并沙子" class="headerlink" title="合并沙子"></a><a href="https://www.acoj.com/problems/12449" target="_blank" rel="noopener">合并沙子</a></h2><p>对于一道典型的区间$\text{DP}$问题，我们很容易思考到如何划分区间（集合）？</p><p>显然，最小的区间是每个数本身，此时合并花费一定最少（因为不需要花费）</p><p>考虑两个数作为一个区间，此时无论怎么合并花费一定最少（只有一种合并方法）</p><p>对于三个数及以上显然不存在直接合并一定最少的情况，例如 $1,3,100$ 如果先合并 $3,100$ 再合并 $1,103$ 总花费是 $207$ ，先合并 $1,3$ 再合并 $4,100$ 总花费则为 $108$。</p><p>那我们可以一直划分一个长度大于等于三的区间，那么显然前一部分的最小加上后一部分的最小使得总体最小，满足最优子结构</p><script type="math/tex; mode=display">\begin{align}f(i,j)=&\min\{f(i,k)+f(k+1,r)+cost(i,j)\} \\      =&\min\{f(i,k)+f(k+1,r)\}+cost(i,j)\end{align}</script><p>其中 $f(i,j)$ 表示合并 $i\sim j$ 的最小花费 $cost(i,j)$ 为合并 $i,j$ 的最小代价</p><p><img src="https://pic.downk.cc/item/5e995fd1c2a9a83be56f8f3f.png" alt=""></p><p>想知道 $cost(i,j)$ 可以采用前缀和</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//f[l][r]=min(f[l][r],f[l][k]+f[k+1][r]+sum(l,r)(l&lt;=k&lt;=r)</span></span><br><span class="line"><span class="keyword">int</span> n,a[<span class="number">305</span>],b[<span class="number">305</span>],f[<span class="number">305</span>][<span class="number">305</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">        b[i]=b[i<span class="number">-1</span>]+a[i],f[i][i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">1</span>;len&lt;n;len++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>;l+len&lt;=n;l++) &#123;</span><br><span class="line">            <span class="keyword">int</span> r=len+l;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;r;k++)</span><br><span class="line">                f[l][r]=min(f[l][r],f[l][k]+f[k+<span class="number">1</span>][r]+b[r]-b[l<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,f[<span class="number">1</span>][n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举每一个长度 $\text{len}$ 的序列的最小合并花费，最终求出 $f(1,n)$ 即最终的最小花费。</p><h2 id="环形合并石子"><a href="#环形合并石子" class="headerlink" title="环形合并石子"></a><a href="https://www.acoj.com/problems/12690" target="_blank" rel="noopener">环形合并石子</a></h2><p>有了上一题的经验，很容易知道这一题的结论也是 $f(i,j) = \min \{ f(i,k) + f(k+1,r) \} + sum(i,j) $  </p><p>难点在于<strong>环形</strong>，我们可以用一个简单的办法解决，原序列展开最多 $n$ 的长度，我们只需要把整个序列复制一遍使其能够计算到 $2n$ 的位置就可以了</p><p><code>a[i+n]=a[i];</code> </p><p>对于最大值和最小值可以开两个数组 f, g 来解决，本质是一样的，但是要枚举每次长度为 $n$ 的序列的起始点才能找到最大值和最小值。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//f[i][j]=min(f[l][r],f[i][k]+f[k+1][r])+sum(l,r)(l&lt;=k&lt;=r)</span></span><br><span class="line"><span class="keyword">int</span> n,a[<span class="number">605</span>],b[<span class="number">605</span>],f[<span class="number">605</span>][<span class="number">605</span>],g[<span class="number">605</span>][<span class="number">605</span>],res1=<span class="number">0x7fffff</span>,res2;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">        a[i+n]=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n*<span class="number">2</span>;i++) b[i]=b[i<span class="number">-1</span>]+a[i],f[i][i]=g[i][i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">1</span>;len&lt;n;len++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>;l+len&lt;=n*<span class="number">2</span>;l++) &#123;</span><br><span class="line">            <span class="keyword">int</span> r=l+len;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=l;k&lt;r;k++)</span><br><span class="line">                f[l][r]=min(f[l][r],f[l][k]+f[k+<span class="number">1</span>][r]+b[r]-b[l<span class="number">-1</span>]);</span><br><span class="line">            g[l][r]=max(g[l][r],g[l][k]+g[k+<span class="number">1</span>][r]+b[r]-b[l<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) res1=min(res1,f[i][i+n<span class="number">-1</span>]),res2=max(res2,g[i][i+n<span class="number">-1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n%d"</span>,res1,res2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="加分二叉树"><a href="#加分二叉树" class="headerlink" title="加分二叉树"></a><a href="https://www.acoj.com/problems/12454" target="_blank" rel="noopener">加分二叉树</a></h2><p>为什么树也是区间$\text{DP}$？</p><p>这里运用了中序遍历的性质（拍扁序）直接成为了一个区间</p><p>每次如果能够更新则根的序号改变。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//f[i][j]=max(f[i][k-1]*f[k+1][j]+a[k])(l&lt;=k&lt;=r)</span></span><br><span class="line"><span class="comment">//k==l||k==r 特殊处理</span></span><br><span class="line"><span class="keyword">int</span> n,a[<span class="number">35</span>],f[<span class="number">35</span>][<span class="number">35</span>],g[<span class="number">35</span>][<span class="number">35</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;r)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>,g[l][r]);</span><br><span class="line">    dfs(l,g[l][r]<span class="number">-1</span>);</span><br><span class="line">    dfs(g[l][r]+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">        f[i][i]=a[i];</span><br><span class="line">        <span class="comment">//叶子节点就直接是自己</span></span><br><span class="line">        g[i][i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">1</span>;len&lt;n;len++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>;l+len&lt;=n;l++) &#123;</span><br><span class="line">            <span class="keyword">int</span> r=l+len;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=l;k&lt;=r;k++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(k==l) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(f[l][r]&lt;a[l]+f[k+<span class="number">1</span>][r])</span><br><span class="line">                        f[l][r]=a[l]+f[k+<span class="number">1</span>][r],g[l][r]=k;</span><br><span class="line">                    <span class="comment">//f[l][r]=max(f[l][r],a[l]+f[k+1][r]);</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(k==r) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(f[l][r]&lt;a[r]+f[l][k<span class="number">-1</span>])</span><br><span class="line">                        f[l][r]=a[r]+f[l][k<span class="number">-1</span>],g[l][r]=k;</span><br><span class="line">                    <span class="comment">//f[l][r]=max(f[l][r],a[r]+f[l][k-1]);</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(f[l][r]&lt;a[k]+f[l][k<span class="number">-1</span>]*f[k+<span class="number">1</span>][r])</span><br><span class="line">                        f[l][r]=a[k]+f[l][k<span class="number">-1</span>]*f[k+<span class="number">1</span>][r],g[l][r]=k;</span><br><span class="line">                    <span class="comment">//f[l][r]=max(f[l][r],a[k]+f[l][k-1]*f[k+1][r]);</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,f[<span class="number">1</span>][n]);</span><br><span class="line">    dfs(<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>限于作者本人能力有限，期待各位多提些建议</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;区间$\text{DP}$比线性$\text{DP}$好想一些。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://answerend42.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="动态规划" scheme="http://answerend42.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="区间DP" scheme="http://answerend42.github.io/tags/%E5%8C%BA%E9%97%B4DP/"/>
    
  </entry>
  
  <entry>
    <title>差分约束算法的一些个人理解</title>
    <link href="http://answerend42.github.io/2020/04/12/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F%E7%AE%97%E6%B3%95%E7%9A%84%E4%B8%80%E4%BA%9B%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/"/>
    <id>http://answerend42.github.io/2020/04/12/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F%E7%AE%97%E6%B3%95%E7%9A%84%E4%B8%80%E4%BA%9B%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/</id>
    <published>2020-04-11T17:26:41.000Z</published>
    <updated>2020-10-09T15:52:04.597Z</updated>
    
    <content type="html"><![CDATA[<p>update on 2020.4.26 新增<a href="https://www.luogu.com.cn/problem/P3275" target="_blank" rel="noopener">糖果</a>代码</p><h2 id="浅谈差分约束"><a href="#浅谈差分约束" class="headerlink" title="浅谈差分约束"></a>浅谈差分约束</h2><p><strong>差分约束系统</strong> 是一种特殊的 $n$ 元一次不等式组，它包含 $n$ 个变量 $x_1,x_2,\cdots x_n$ 以及 $m$ 个约束条件，每个约束条件是由两个其中的变量做差构成的，形如 $x_i-x_j \leq c_k$，其中 $c_k$ 是常数（可以是非负数，也可以是负数）。我们要解决的问题是：求一组解 ，使得所有的约束条件得到满足，否则判断出无解。</p><a id="more"></a><p>差分约束系统中的每个约束条件 $x_i-x_j\leq c_k$ 都可以变形成 $x_i \leq x_j+c_k$，这与单源最短路中的三角形不等式 $dist[y] \leq dist[x]+z$ 非常相似。因此，我们可以把每个变量 $x_i$ 看做图中的一个结点，对于每个约束条件 $x_i-x_j\leq c_k$，从结点 $j$ 向结点 $i$ 连一条长度为 $c_k$ 的有向边。</p><p>注意到，如果 ${a_1,a_2,\cdots ,a_n}$ 是该差分约束系统的一组解，那么对于任意的常数 $d$，${a_1+d,a_2+d,\cdots ,a_n}$ 显然也是该差分约束系统的一组解，因为这样做差后 $d$ 刚好被消掉。</p><p>设 $dist[0]=0$ 并向每一个点连一条边，跑单源最短路，若图中存在负环，则给定的差分约束系统无解，否则，$x_i=dist[i]$ 为该差分约束系统的一组解。</p><p>一般使用 Bellman-Ford 或队列优化的 Bellman-Ford（俗称 SPFA，在某些随机图跑得很快）判断图中是否存在负环，最坏时间复杂度为 $O(nm)$。</p><blockquote><p>个人理解：</p><ol><li><p>差分约束系统是一种特殊的 $n$ 元一次不等式组</p></li><li><p>约束条件形如 $x_i-x_j \leq c_k$</p></li><li><p>一些对照</p></li></ol><div class="table-container"><table><thead><tr><th style="text-align:center">差分约束中的条件</th><th style="text-align:center">三角形不等式中的条件</th></tr></thead><tbody><tr><td style="text-align:center">$x_i$​</td><td style="text-align:center">$dist[y]$</td></tr><tr><td style="text-align:center">$x_j$​</td><td style="text-align:center">$dist[x]$</td></tr><tr><td style="text-align:center">$c_k$​</td><td style="text-align:center">$z$​</td></tr></tbody></table></div><ol><li><p>$dist[0]$ 其实就是建立了超级源点</p></li><li><script type="math/tex; mode=display">\left\{\begin{aligned}x_1 \leq x_3+3 \\x_2 \leq x_1-5 \\x_3 \leq x_2-3\end{aligned}\right.</script><p>以此为例建图</p><p><img src="https://pic.downk.cc/item/5e91f3c8504f4bcb0407f4ae.png" alt=""></p><p>显然 1→2→3→1 形成了一个负环，显然是不可解的（此时无最短路）</p></li><li><p>为什么？我的理解是如果建出的图存在有负环，那么原差分约束系统中的约束条件必然相互矛盾，上例中是 $x_1 \leq x_1-5$</p></li><li><p>实际上这是一种抽象的概念，将某一类复杂的问题巧妙的结合在图论模型中再用最短路求解，实际上，图论问题，建图最难</p></li></ol></blockquote><p>SPFA虽然已经成为了被卡掉的算法（包括各个优化），其实用性仍然是很好的。</p><p>如果以 $x_1,x_2$ 表示两个变量，$x_1-x_2 \leq c$ 有如下条件是等价的</p><script type="math/tex; mode=display">x_1-x_2 \leq c \Leftrightarrow  x_1-x_2 \geq -c \Leftrightarrow x_1-x_2 < c+1 \Leftrightarrow x_1-x_2 > -c-1</script><p> 如果 $x_1-x_2=c$，有 $x_1-x_2 \geq c,x_1-x_2 \leq c$</p><p>（其实上面的做法是为了解决糖果这道题）</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">5</span>,M = N*<span class="number">3</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">int</span> n,m,op,x,y,idx,v[M],w[M],dis[N],book[N],cnt[N],first[N],nxt[M];</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">    v[++idx]=y;</span><br><span class="line">    w[idx]=z;</span><br><span class="line">    nxt[idx]=first[x];</span><br><span class="line">    first[x]=idx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    book[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">-0x3f</span>,<span class="keyword">sizeof</span>(dis));</span><br><span class="line">    dis[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> t=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        book[t]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(cnt[t]++==n<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=first[t];i;i=nxt[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> p=v[i];</span><br><span class="line">            <span class="keyword">if</span>(dis[p]&lt;dis[t]+w[i]) &#123;</span><br><span class="line">                dis[p]=dis[t]+w[i];</span><br><span class="line">                <span class="keyword">if</span>(!book[p]) &#123;</span><br><span class="line">                    book[p]=<span class="number">1</span>;</span><br><span class="line">                    q.push(p);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;op,&amp;x,&amp;y);</span><br><span class="line">        <span class="keyword">switch</span>(op) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                add(x,y,<span class="number">0</span>);add(y,x,<span class="number">0</span>);<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                add(x,y,<span class="number">1</span>);<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                add(y,x,<span class="number">0</span>);<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                add(y,x,<span class="number">1</span>);<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                add(x,y,<span class="number">0</span>);<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(op%<span class="number">2</span>==<span class="number">0</span>&amp;&amp;x==y) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"-1"</span>),<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--) add(<span class="number">0</span>,i,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(!spfa())</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"-1"</span>),<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        ans+=dis[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;update on 2020.4.26 新增&lt;a href=&quot;https://www.luogu.com.cn/problem/P3275&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;糖果&lt;/a&gt;代码&lt;/p&gt;
&lt;h2 id=&quot;浅谈差分约束&quot;&gt;&lt;a href=&quot;#浅谈差分约束&quot; class=&quot;headerlink&quot; title=&quot;浅谈差分约束&quot;&gt;&lt;/a&gt;浅谈差分约束&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;差分约束系统&lt;/strong&gt; 是一种特殊的 $n$ 元一次不等式组，它包含 $n$ 个变量 $x_1,x_2,\cdots x_n$ 以及 $m$ 个约束条件，每个约束条件是由两个其中的变量做差构成的，形如 $x_i-x_j \leq c_k$，其中 $c_k$ 是常数（可以是非负数，也可以是负数）。我们要解决的问题是：求一组解 ，使得所有的约束条件得到满足，否则判断出无解。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://answerend42.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="图论" scheme="http://answerend42.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="最短路" scheme="http://answerend42.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
      <category term="SPFA" scheme="http://answerend42.github.io/tags/SPFA/"/>
    
      <category term="差分约束" scheme="http://answerend42.github.io/tags/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces Round 629 (Div. 3)</title>
    <link href="http://answerend42.github.io/2020/03/27/cf/Codeforces%20Round%20629%20(Div.%203)/"/>
    <id>http://answerend42.github.io/2020/03/27/cf/Codeforces%20Round%20629%20(Div.%203)/</id>
    <published>2020-03-27T15:56:32.000Z</published>
    <updated>2020-08-04T16:15:14.936Z</updated>
    
    <content type="html"><![CDATA[<h2 id="A-Divisibility-Problem"><a href="#A-Divisibility-Problem" class="headerlink" title="A Divisibility Problem"></a><a href="https://www.luogu.com.cn/problem/CF1328A" target="_blank" rel="noopener">A Divisibility Problem</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定两个正整数 $a$ 和 $b$，你可以在一步操作中将 $a$ 加上 $1$。你需要找到最少需要多少步操作可以使得 $a \mid b $。存在最开始就满足 $a \mid b$ 的可能从而只需要 $0$ 步操作。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行一个正整数 $t( 1 \le t \le 10^4)$。</p><p>之后 $t$ 行每行两个正整数 $a,b(1\le a,b \le 10^9)$。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出共 $t$ 行，每行一个整数，表示能达到 $a\mid b$ 的最小操作步数。</p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>题面上描述的是 $a \mid b$ 也就是 $a$ 能够整除 $b$ ，对于 $a \nmid b$ 一定是形如 $a \div b=c\cdots d$ ，那么相当于去枚举一个 $c$ 。我们可以知道 $b\times( c+1)$ 就是第一个能整除 $b$ 的整数，一开始是 $c\times b$ 现在是 $(c+1)\times b$ ，所以多了一个 $b$ ，之前比 $c\times b$ 多了 $d$ 最终所需要的答案也就是 $b-d$。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, a, b;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line"><span class="keyword">if</span>(a % b == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, b - a % b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-K-th-Beautiful-String"><a href="#B-K-th-Beautiful-String" class="headerlink" title="B K-th Beautiful String"></a><a href="https://www.luogu.com.cn/problem/CF1328B" target="_blank" rel="noopener">B K-th Beautiful String</a></h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定两个正整数 $n,k$，生成 $\frac{n \cdot (n-1)}{2}$ 组长度为 $n$ 其中 $n-2$ 个 <code>a</code> ，$2$ 个 <code>b</code> 的字符串，求按字典序排序后第 $k$ 个字符串。</p><p>对于两个长度相等的字符串 $s,t$ 如果存在 $i(1\le i \le n)$ 使得 $s_i&lt;t_i$ 且存在 $j( 1 \le j &lt; i )$ 使得 $s_j = t_j$，$s$ 的字典序小于 $t$。</p><p>这是 $n=5$ 时的一个例子：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aaabb</span><br><span class="line">aabab</span><br><span class="line">aabba</span><br><span class="line">abaab</span><br><span class="line">ababa</span><br><span class="line">abbaa</span><br><span class="line">baaab</span><br><span class="line">baaba</span><br><span class="line">babaa</span><br><span class="line">bbaaa</span><br></pre></td></tr></table></figure><h3 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行一个正整数 $t( 1 \le t \le 10^4)$。</p><p>之后 $t$ 行每行两个正整数 $n,k(3\le n \le 10^5,1 \le k \le \min(2 \cdot 10^9,\frac{n \cdot (n-1)}{2}))$。</p><h3 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出共 $t$ 行，每行一个字符串，表示按字典序排序后第 $k$ 个字符串。</p><h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><p>我们用 $x$ 来表示第一个 <code>b</code> 出现的位置，用 $y$ 来表示第二个 <code>b</code> 出现的位置，一开始 $x=n-1,y=n$，我们发现有如下规则</p><ol><li>$x=y-1$，$x\gets x-1,y=n$</li><li>$x \ne y-1$，$y\gets y-1$</li></ol><p>如果只考虑 $x$ ，当 $y = n$ 的时候，要移动到 $x$，需要 $n-x+1$ 步。</p><p>而 $x$ 的分布规律和 $k_i$ 的分布也是有关系的，拿题目中的样例解释</p><ol><li><code>aaabb</code> $x=4,y=5,k=1$</li><li><code>aabab</code> $x=3,y=5,k=2$</li><li><code>aabba</code> $x=3,y=4,k=3$</li><li><code>abaab</code> $x=2,y=5,k=4$</li><li><code>ababa</code> $x=2,y=4,k=5$</li><li><code>abbaa</code> $x=2,y=3,k=6$</li><li><code>baaab</code> $x=1,y=5,k=7$</li><li><code>baaba</code> $x=1,y=4,k=8$</li><li><code>babaa</code> $x=1,y=3,k=9$</li><li><code>bbaaa</code> $x=1,y=2,k=10$</li></ol><p>我们提取出每次使得 $x$ 的值同上一个 $x$ 的值不同的 $k$ 也就是 ${1,2,4,7,\cdots}$</p><p>这些数有什么规律呢？很容易发现这个数列的规律是 $+1,+2,+3,+\cdots$</p><p>我们可以处理出这样的一个数列 $ka={1,2,4,7,\cdots}$，那么对于 <script type="math/tex">[ka_i,ka_{i+1})</script> 这么一个区间中的每一个 <script type="math/tex">x</script> 都满足 <script type="math/tex">x=n-i,y=n-k+ka_i</script> ，这一题的代码如下</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">char</span> ch[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> k[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">int</span> t,a,b,p;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">getcha</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">100000</span>],*p1=buf,*p2=buf;</span><br><span class="line">    <span class="keyword">return</span> p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,<span class="number">1</span>,<span class="number">100000</span>,<span class="built_in">stdin</span>),p1==p2)?EOF:*p1++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch=getcha();<span class="keyword">int</span> ret=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">'0'</span>||ch&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">'-'</span>)f=-f;ch=getcha();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">'0'</span>&amp;&amp;ch&lt;=<span class="string">'9'</span>)&#123;ret=(ret&lt;&lt;<span class="number">1</span>)+(ret&lt;&lt;<span class="number">3</span>)+ch-<span class="string">'0'</span>;ch=getcha();&#125;</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">k[<span class="number">1</span>]=<span class="number">1</span>,k[<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=<span class="number">100005</span>;++i) k[i]=k[i<span class="number">-1</span>]+i<span class="number">-1</span>;</span><br><span class="line">t=read();</span><br><span class="line"><span class="keyword">while</span>(t--) &#123;</span><br><span class="line">a=read(),b=read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=a;++i) ch[i]=<span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=a;++i) <span class="keyword">if</span>(k[i+<span class="number">1</span>]&gt;b) &#123;p=i;<span class="keyword">break</span>;&#125;</span><br><span class="line"><span class="comment">//也可以用p=lower_bound(k+1,k+1+a,b+1)-k-1;</span></span><br><span class="line">ch[a-p]=ch[a-b+k[p]]=<span class="string">'b'</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=a;i++) <span class="built_in">printf</span>(<span class="string">"%c"</span>,ch[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Ternary-XOR"><a href="#C-Ternary-XOR" class="headerlink" title="C Ternary XOR"></a><a href="https://www.luogu.com.cn/problem/CF1328C" target="_blank" rel="noopener">C Ternary XOR</a></h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>一个三进制数各位必定由 $0,1,2$ 组成，例如 $1022,11,21,2022$。</p><p>给定一个三进制数 $x$,$x$ 的首位必定为 $2$，其余位数有可能是 $0$ 或 $1$ 或 $2$ 。</p><p>我们定义三进制的异或操作符 $⊙$，对于两个长度均为 $n$ 的三进制数 $a,b$ ，$a⊙b$ 的结果为 $c$，$c_i=(a_i+b_i) \bmod 3 $。这也就是说，将 $a,b$ 相应的数字相加并除以 $3$。例如，$10222⊙11021=21210$。</p><p>你需要找到两个长度为 $n$ 且没有前导零的三进制数 $a,b$ 使得 $a⊙b=x$ 且 $\max {a,b }$ 最小。</p><h3 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行一个正整数 $t( 1 \le t \le 10^4)$。</p><p>之后 $t$ 组数据每组数据第一行一个正整数 $n(1 \le n \le 5 \cdot 10^4)$ 表示 $x$ 的长度为 $n$，第二行一个长度为 $n$ 的三进制数 $x$ （$x$ 由 $n$ 个 $0$ 或 $1$ 或 $2$ 组成且没有前导零）。</p><p>保证所有组数据 $n$ 的总和不超过 $5 \cdot 10^4(\sum n \le 5 \cdot 10^4)$。</p><h3 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出共 $t$ 组，每组两行，两个使得 $a⊙b=x$ 且 $\max {a,b }$ 最小的长度为 $n$ 的三进制数 $a,b$。</p><p>如果有多组 $a,b$ 满足条件，输出任意一种。</p><h3 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h3><p>如果要使 $\max {a,b }$ 最小，那么一定不存在进位。</p><p>对于 $a=b$ </p><ol><li>$x_i=0$ $a_i=b_i=0$</li><li>$x_i=1$ $a_i=1,b_i=0$</li><li>$x_i=2$ $a_i=b_i=1$ </li></ol><p>对于 $a&gt;b$</p><ol><li>$x_i=0$ $a_i=b_i=0$</li><li>$x_i=1$ $a_i=0,b_i=1$</li><li>$x_i=2$ $a_i=0,b_i=2$</li></ol><p>（因为 $a=b$ 时的第二条规则保证存在至少一个 $i$ 使得 $a_i&gt;b_i$ 从而保证了 $a&gt;b$ 所以可以在 $a&gt;b$ 时把所有位上的数给 $b$，避免将 $a$ 的值增大）</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch=getchar();<span class="keyword">int</span> ret=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">'0'</span>||ch&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">'-'</span>)f=-f;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">'0'</span>&amp;&amp;ch&lt;=<span class="string">'9'</span>)&#123;ret=(ret&lt;&lt;<span class="number">1</span>)+(ret&lt;&lt;<span class="number">3</span>)+ch-<span class="string">'0'</span>;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> t,len,flag;</span><br><span class="line"><span class="keyword">char</span> c[<span class="number">50015</span>],c1[<span class="number">50015</span>],c2[<span class="number">50015</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">t=read();</span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        len=read();</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,c+<span class="number">1</span>);</span><br><span class="line">flag=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;i++)</span><br><span class="line">        &#123;</span><br><span class="line"><span class="keyword">if</span>(c[i]==<span class="string">'2'</span>)</span><br><span class="line">            &#123;</span><br><span class="line"><span class="keyword">if</span>(!flag) c1[i]=c2[i]=<span class="string">'1'</span>;</span><br><span class="line"><span class="keyword">else</span> c1[i]=<span class="string">'0'</span>,c2[i]=<span class="string">'2'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(c[i]==<span class="string">'1'</span>)</span><br><span class="line">            &#123;</span><br><span class="line"><span class="keyword">if</span>(!flag) c1[i]=<span class="string">'1'</span>,c2[i]=<span class="string">'0'</span>,flag=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> c1[i]=<span class="string">'0'</span>,c2[i]=<span class="string">'1'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(c[i]==<span class="string">'0'</span>) c1[i]=c2[i]=<span class="string">'0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;i++) <span class="built_in">printf</span>(<span class="string">"%c"</span>,c1[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;i++) <span class="built_in">printf</span>(<span class="string">"%c"</span>,c2[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;A-Divisibility-Problem&quot;&gt;&lt;a href=&quot;#A-Divisibility-Problem&quot; class=&quot;headerlink&quot; title=&quot;A Divisibility Problem&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www
      
    
    </summary>
    
    
      <category term="比赛" scheme="http://answerend42.github.io/categories/%E6%AF%94%E8%B5%9B/"/>
    
    
      <category term="模拟" scheme="http://answerend42.github.io/tags/%E6%A8%A1%E6%8B%9F/"/>
    
      <category term="数论" scheme="http://answerend42.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="贪心" scheme="http://answerend42.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="数学" scheme="http://answerend42.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>P6236 [COCI2010-2011] LJUTNJA</title>
    <link href="http://answerend42.github.io/2020/03/25/lg6236/lg6236/"/>
    <id>http://answerend42.github.io/2020/03/25/lg6236/lg6236/</id>
    <published>2020-03-25T04:54:15.000Z</published>
    <updated>2020-03-27T07:25:54.164Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P6236" target="_blank" rel="noopener">原题链接</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>幼儿园的小孩们收到了一个有 $m$ 颗糖果的大包裹，现在要把这些糖果分给 $n$ 个小孩。</p><p>每一个小孩都给出了一个期望的糖果数，如果没有达到他的期望值 $a_i$，小孩就会生气。每差一个糖果，小孩的生气指数就会增加，可以认为他生气的程度等于他少得到的糖果数的平方。</p><p>比如，Mirko 想要得到 $32$ 个糖果，但是只得到了 $29$ 个。他少了 $3$ 个，所以他的生气指数是 $9$。不幸的是，糖果数不足以满足所有小孩的期望。所以我们应该采取最优的分配方法，使得最后小孩们的生气指数的和最小。</p><h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入数据共 $n+1$ 行。</p><p>第一行两个整数 $m,n$。</p><p>接下来 $n$ 行，每行一个整数，第 $i+1$ 行的整数表示第 $i$ 个小朋友期望值 $a_i$。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出数据共一行。</p><p>一行一个整数，表示最小的总生气指数。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 4</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>输出1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>这一题首先要知道分糖果的策略，我们通过样例进行研究，将  $1$ 个糖果分给任意一个小朋友，怎样才是最优的？如果给 <script type="math/tex">a_i=5</script> 的小朋友那么生气指数减少了 <script type="math/tex">5^2-4^2=9</script>，给 <script type="math/tex">a_i=4</script> 的小朋友那么生气指数减少了 <script type="math/tex">4^2-3^2=7</script> 的生气指数，以此类推，给 <script type="math/tex">i</script> 号小朋友实质上生气指数会减少 <script type="math/tex">{a_i}^2-(a_i-1)^2</script> 而给了一个之后 $a_i$ 就会变成 $a_i-1$ 我们只要找到每次给糖果之后生气指数减少最多的（也就是当前离目标差值最大的）就可以做了。</p><p>我拿样例来解释一下这个过程</p><ol><li><p>排序得到 $5,4,3,2$</p></li><li><p>找到最大值 $maxn$ 为 $5$，在 $m&gt;0$ 的情况下把所有 $a_i =maxn$ $a_i\gets a_i-1$ 同时 $m \gets m-1$</p></li><li><p>找到最大值 $maxn$ 为 $4$，在 $m&gt;0$ 的情况下把所有 $a_i =maxn$ $a_i\gets a_i-1$ 同时 $m \gets m-1$</p></li><li>找到最大值 $maxn$ 为 $3$，在 $m&gt;0$ 的情况下把所有 $a_i =maxn$ $a_i\gets a_i-1$ 同时 $m \gets m-1$</li><li>找到最大值 $maxn$ 为 $2$，在 $m&gt;0$ 的情况下把所有 $a_i =maxn$ $a_i\gets a_i-1$ 同时 $m \gets m-1$</li><li>$m=0$ 结束，计算最终和 $sum$ </li></ol><p>抽象一下</p><ol><li>排序</li><li>找到最大值，所有最大值减一（满足 $m&gt;0$）不断重复此过程</li><li>计算最终和 $sum$ </li></ol><p>如果还不明白的话就看一下代码吧（注意，unsigned long long 的最大值才是 $2^{64}-1$ ）</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> a[<span class="number">100005</span>],sum,n,m,maxn,idx=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch=getchar();<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ret=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">'0'</span>||ch&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">'-'</span>)f=-f;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">'0'</span>&amp;&amp;ch&lt;=<span class="string">'9'</span>)&#123;ret=(ret&lt;&lt;<span class="number">1</span>)+(ret&lt;&lt;<span class="number">3</span>)+ch-<span class="string">'0'</span>;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m=read(),n=read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i]=read();</span><br><span class="line">    sort(a+<span class="number">1</span>,a+<span class="number">1</span>+n,greater&lt;<span class="keyword">int</span>&gt;());<span class="comment">//从大到小排序</span></span><br><span class="line">    maxn=a[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span>(m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[idx]!=maxn)</span><br><span class="line">        &#123;</span><br><span class="line">            maxn=a[<span class="number">1</span>],idx=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">        a[idx]-=<span class="number">1</span>,m-=<span class="number">1</span>,idx++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) sum+=a[i]*a[i];<span class="comment">//计算最终和</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%llu"</span>,sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P6236&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原题链接&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerl
      
    
    </summary>
    
    
      <category term="题解" scheme="http://answerend42.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="模拟" scheme="http://answerend42.github.io/tags/%E6%A8%A1%E6%8B%9F/"/>
    
      <category term="数论" scheme="http://answerend42.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="数学" scheme="http://answerend42.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>第一次CF比赛</title>
    <link href="http://answerend42.github.io/2020/03/24/%E7%AC%AC%E4%B8%80%E6%AC%A1CF%E6%AF%94%E8%B5%9B/%E7%AC%AC%E4%B8%80%E6%AC%A1CF%E6%AF%94%E8%B5%9B/"/>
    <id>http://answerend42.github.io/2020/03/24/%E7%AC%AC%E4%B8%80%E6%AC%A1CF%E6%AF%94%E8%B5%9B/%E7%AC%AC%E4%B8%80%E6%AC%A1CF%E6%AF%94%E8%B5%9B/</id>
    <published>2020-03-24T14:26:01.000Z</published>
    <updated>2020-03-24T15:43:01.226Z</updated>
    
    <content type="html"><![CDATA[<p>CF上的题目确实值得一做，打比赛是提升代码水平的好方法。</p><a id="more"></a><h2 id="参赛感想"><a href="#参赛感想" class="headerlink" title="参赛感想"></a>参赛感想</h2><p>​    我参加的第一场 CF 比赛是 Educational Codeforces Round 84 (Rated for Div. 2)。我很早就注册了CF账号，但是打比赛还是第一次。原先总觉得CF的题都好难，实际上真正去做的时候发现自己只要有时间还是可以做出来几题的。CF的题目是典型的思维题，没有思维很难想到。最终的码量都不会很大（这让我在最后时刻抢着把 B 题做完了）。（非常感谢 too_late 对我的鼓励）</p><h2 id="题解（只有-A-B-C）"><a href="#题解（只有-A-B-C）" class="headerlink" title="题解（只有 A,B,C）"></a>题解（只有 A,B,C）</h2><h3 id="A-Sum-of-Odd-Integers"><a href="#A-Sum-of-Odd-Integers" class="headerlink" title="A Sum of Odd Integers"></a><a href="https://www.luogu.com.cn/problem/CF1327A" target="_blank" rel="noopener">A Sum of Odd Integers</a></h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定 $n,k$,求是否能用 $k$ 个不同奇数的和来表示 $n$。</p><h4 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h4><h5 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h5><p>第一行一个正整数 $t(1\leq t\leq 10^5)$</p><p>之后 $t$ 每行两个正整数 $n,k(1\leq n,k \leq 10^7)$</p><h5 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h5><p>如果有解，输出 <code>YES</code>，否则输出 <code>NO</code>。</p><h4 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h4><p>输入1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">3 1</span><br><span class="line">4 2</span><br><span class="line">10 3</span><br><span class="line">10 2</span><br><span class="line">16 4</span><br><span class="line">16 5</span><br></pre></td></tr></table></figure><p>输出1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">YES</span><br><span class="line">YES</span><br><span class="line">NO</span><br><span class="line">YES</span><br><span class="line">YES</span><br><span class="line">NO</span><br></pre></td></tr></table></figure><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>​    这一题一开始先手玩了一下</p><div class="table-container"><table><thead><tr><th>数字 $n$</th><th>可以满足的 $k$</th><th>解释</th></tr></thead><tbody><tr><td>$1$</td><td>$1$</td><td>$1=1$</td></tr><tr><td>$2$</td><td>无</td><td>$1+3=4&gt;2$</td></tr><tr><td>$3$</td><td>$1$</td><td>$3=3$</td></tr><tr><td>$4$</td><td>$2$</td><td>$1+3=4$</td></tr><tr><td>$5$</td><td>$1$</td><td>$5=5$</td></tr><tr><td>$6$</td><td>$2$</td><td>$1+5=6$</td></tr><tr><td>$7$</td><td>$1$</td><td>$7=7$</td></tr><tr><td>$8$</td><td>$2$</td><td>$3+5=8$</td></tr><tr><td>$9$</td><td>$1,3$</td><td>$9=9$,$1+3+5=9$</td></tr></tbody></table></div><p>可以发现一个规律，$n,k$ 的奇偶性都是相同的，也许并不那么显然。还有一个规律，所有满足条件的 $k$ 都是小于 $\sqrt n$ 的，这个题目的证明可以参照 <a href="https://www.luogu.com.cn/blog/writeSTL/solution-cf1327a" target="_blank" rel="noopener">jijidawang 的博客</a>。</p><p>得出</p><blockquote><p>$n-k^2\ge 0$ 且 $(n-k^2)\bmod 2=0$ 是有解的<strong>充要条件</strong>。</p></blockquote><p>代码就呼之欲出了（但是很坑的是计算 $k^2$ 要开 long long）</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch=getchar();<span class="keyword">long</span> <span class="keyword">long</span> ret=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">'0'</span>||ch&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">'-'</span>)f=-f;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">'0'</span>&amp;&amp;ch&lt;=<span class="string">'9'</span>)&#123;ret=(ret&lt;&lt;<span class="number">1</span>)+(ret&lt;&lt;<span class="number">3</span>)+ch-<span class="string">'0'</span>;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> t,n,k;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t=read();</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        n=read(),k=read();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s"</span>,n%<span class="number">2</span>==k%<span class="number">2</span>&amp;&amp;n&gt;=k*k?<span class="string">"YES\n"</span>:<span class="string">"NO\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="B-Princesses-and-Princes"><a href="#B-Princesses-and-Princes" class="headerlink" title="B Princesses and Princes"></a><a href="https://www.luogu.com.cn/problem/CF1327B" target="_blank" rel="noopener">B Princesses and Princes</a></h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>有 $n$ 个公主和王子，每个公主依次选择她喜欢并且没有结婚的王子结婚，问能不能让一个公主再多喜欢一个王子，使得最终配对的对数更多。</p><h4 id="输入输出格式-1"><a href="#输入输出格式-1" class="headerlink" title="输入输出格式"></a>输入输出格式</h4><h5 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h5><p>第一行一个正整数 $t(1\leq t\leq 10^5)$</p><p>之后 $t$ 组数据</p><p>每组数据第一行 $1$ 个正整数 $n(1\leq n \leq 10^5)$</p><p>接下来 $n$ 行每行第一个正整数 $k(0\leq k\leq n)$ 随后 $k$ 个正整数表示第 $i$ 个公主可以配对的王子编号</p><h5 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h5><p>如果可以通过加入一个不在公主喜欢名单中的王子到这个公主的喜欢名单中使得配对数更多，输出两行，第一行 <code>IMPROVE</code>，第二行两个对应的公主王子编号，否则输出一行，<code>OPTIMAL</code>。</p><h4 id="输入输出样例-1"><a href="#输入输出样例-1" class="headerlink" title="输入输出样例"></a>输入输出样例</h4><p>输入1 :</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">4</span><br><span class="line">2 2 3</span><br><span class="line">2 1 2</span><br><span class="line">2 3 4</span><br><span class="line">1 3</span><br><span class="line">2</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">3</span><br><span class="line">3 1 2 3</span><br><span class="line">3 1 2 3</span><br><span class="line">3 1 2 3</span><br><span class="line">1</span><br><span class="line">1 1</span><br><span class="line">4</span><br><span class="line">1 1</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br></pre></td></tr></table></figure><p>输出1 :</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IMPROVE</span><br><span class="line">4 4</span><br><span class="line">IMPROVE</span><br><span class="line">1 1</span><br><span class="line">OPTIMAL</span><br><span class="line">OPTIMAL</span><br><span class="line">OPTIMAL</span><br></pre></td></tr></table></figure><h4 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h4><p>非常简单的模拟。（但是要注意不要使用 <code>memset</code> 会超时，直接 <code>for</code> 赋值就好了）</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100005</span>],b[<span class="number">100005</span>],n,t,m,p;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch=getchar();<span class="keyword">int</span> ret=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">'0'</span>||ch&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">'-'</span>)f=-f;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">'0'</span>&amp;&amp;ch&lt;=<span class="string">'9'</span>)&#123;ret=(ret&lt;&lt;<span class="number">1</span>)+(ret&lt;&lt;<span class="number">3</span>)+ch-<span class="string">'0'</span>;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t=read();</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> flag1=<span class="number">0</span>,flag2=<span class="number">0</span>;</span><br><span class="line">        n=read();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i]=b[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            m=read();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                p=read();</span><br><span class="line">                <span class="keyword">if</span>(b[p]==<span class="number">0</span>&amp;&amp;a[i]==<span class="number">0</span>) a[i]=<span class="number">1</span>,b[p]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]==<span class="number">0</span>) flag1=i;</span><br><span class="line">            <span class="keyword">if</span>(b[i]==<span class="number">0</span>) flag2=i;</span><br><span class="line">            <span class="keyword">if</span>(flag1&amp;&amp;flag2) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag1&amp;&amp;flag2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"IMPROVE\n%d %d\n"</span>,flag1,flag2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"OPTIMAL\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-Game-with-Chips"><a href="#C-Game-with-Chips" class="headerlink" title="C Game with Chips"></a><a href="https://www.luogu.com.cn/problem/CF1327C" target="_blank" rel="noopener">C Game with Chips</a></h3><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><p>Petya 有一个大小为 $n×m$ 的矩形版。一开始，在板子上有 $k$ 个芯片，第 $i$ 个芯片位置位于第 $sx$ 行与第 $sy$ 列的相交点上。</p><p>在一次操作中， Petya 可以把所有的芯片向左、向右、向下或者向上移动一格。</p><p>如果芯片在 $(x, y)$ 格中，则在操作之后：</p><ul><li>往左：坐标为 $(x, y - 1)$;</li><li>往右：坐标为 $(x, y + 1)$;</li><li>往下：坐标为 $(x + 1, y)$;</li><li>往上：坐标为 $(x - 1, y)$;</li></ul><p>如果现在芯片在版的边缘上，然而 Petya 将其移向边缘，那么芯片的位置保持不变。</p><p>对于每一个芯片， Petya 选择了它应该到达的位置。注意 芯片不需要在这个地方停下来。</p><p>由于 Petya 时间不多， 总操作数不能超过 $2nm$。</p><p>你需要求出 Petya 应该做的操作：在不超过 $2nm$ 次的操作里让每个芯片走过 Petya 选定的位置一遍。或者说明是不可能达到目的的。</p><h4 id="输入输出格式-2"><a href="#输入输出格式-2" class="headerlink" title="输入输出格式"></a>输入输出格式</h4><h5 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h5><p>第一行三个正整数 $n,m,k ( 1 \le n, m, k \le 200)$ </p><p>接下来 $k$ 行每行两个正整数 $sx,sy$ 表示每个芯片的初始位置</p><p>接下来 $k$ 行每行两个正整数 $fx,fy$ 表示每个芯片应该经过的位置</p><h5 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h5><p>在第一行中输出操作的次数，以便每个芯片至少访问一次 Petya 为其选择的位置。<br>在第二行中输出操作序列。为了表示左、右、下和上的操作，分别使用字符 <code>L</code>,<code>R</code>,<code>D</code>,<code>U</code>。<br>如果所需的序列不存在，请在单行中打印 <code>-1</code>。</p><h4 id="输入输出样例-2"><a href="#输入输出样例-2" class="headerlink" title="输入输出样例"></a>输入输出样例</h4><p>输入1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 3 2</span><br><span class="line">1 2</span><br><span class="line">2 1</span><br><span class="line">3 3</span><br><span class="line">3 2</span><br></pre></td></tr></table></figure><p>输出1：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">DRD</span><br></pre></td></tr></table></figure><p>输入2：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 4 3</span><br><span class="line">3 4</span><br><span class="line">3 1</span><br><span class="line">3 3</span><br><span class="line">5 3</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br></pre></td></tr></table></figure><p>输出2：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">9</span><br><span class="line">DDLUUUURR</span><br></pre></td></tr></table></figure><h4 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h4><p>​    奇妙思路，将所有芯片通过至多 $m-1$ 次向右的操作和至多 $n-1$ 次向下的操作放到右下角，然后暴力扫一遍，总共的次数 $mn+m+n-3<2nm$ 。但是要特判 $n+m>nm$ 的情况，也很简单。所以说，这一题和 $k,sx,sy,fx,fy$ 无关直接输出方案就行了。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch=getchar();<span class="keyword">int</span> ret=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">'0'</span>||ch&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">'-'</span>)f=-f;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">'0'</span>&amp;&amp;ch&lt;=<span class="string">'9'</span>)&#123;ret=(ret&lt;&lt;<span class="number">1</span>)+(ret&lt;&lt;<span class="number">3</span>)+ch-<span class="string">'0'</span>;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m,k,idx;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=read(),m=read(),k=read();</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,m*<span class="number">2</span><span class="number">-2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m<span class="number">-1</span>;i++)<span class="built_in">printf</span>(<span class="string">"R"</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m<span class="number">-1</span>;i++)<span class="built_in">printf</span>(<span class="string">"L"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">1</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,n*<span class="number">2</span><span class="number">-2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)<span class="built_in">printf</span>(<span class="string">"D"</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)<span class="built_in">printf</span>(<span class="string">"U"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,m*n+m+n<span class="number">-3</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m<span class="number">-1</span>;i++)<span class="built_in">printf</span>(<span class="string">"R"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)<span class="built_in">printf</span>(<span class="string">"D"</span>);</span><br><span class="line">    <span class="keyword">while</span>(idx!=m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)<span class="built_in">printf</span>(<span class="string">"%c"</span>,idx%<span class="number">2</span>==<span class="number">0</span>?<span class="string">'U'</span>:<span class="string">'D'</span>);</span><br><span class="line">        idx++;</span><br><span class="line">        <span class="keyword">if</span>(idx==m) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"L"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="D-E-F-G我都不会，也没时间去做了，如果以后做了会放代码的"><a href="#D-E-F-G我都不会，也没时间去做了，如果以后做了会放代码的" class="headerlink" title="D E F G我都不会，也没时间去做了，如果以后做了会放代码的"></a>D E F G我都不会，也没时间去做了，如果以后做了会放代码的</h3><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>第一次 CF 的体验还是很不错的，就是没有那种竞赛的状态，速度也提不上来（再次证明我的题做的太少了），感谢观看。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CF上的题目确实值得一做，打比赛是提升代码水平的好方法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="比赛" scheme="http://answerend42.github.io/categories/%E6%AF%94%E8%B5%9B/"/>
    
    
      <category term="模拟" scheme="http://answerend42.github.io/tags/%E6%A8%A1%E6%8B%9F/"/>
    
      <category term="数论" scheme="http://answerend42.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="贪心" scheme="http://answerend42.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="数学" scheme="http://answerend42.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="奇偶性" scheme="http://answerend42.github.io/tags/%E5%A5%87%E5%81%B6%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>生动形象的理解二维前缀和</title>
    <link href="http://answerend42.github.io/2020/03/15/%E7%94%9F%E5%8A%A8%E5%BD%A2%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C/%E7%94%9F%E5%8A%A8%E5%BD%A2%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    <id>http://answerend42.github.io/2020/03/15/%E7%94%9F%E5%8A%A8%E5%BD%A2%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C/%E7%94%9F%E5%8A%A8%E5%BD%A2%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C/</id>
    <published>2020-03-15T15:39:35.000Z</published>
    <updated>2020-10-06T15:36:24.659Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在<a href="https://answerend42.github.io/Answerend42.github.io/2020/03/08/P6180%20%E3%80%90%5BUSACO15DEC%5DBreed%20Counting%20S%E3%80%91/P6180%20%E3%80%90%5BUSACO15DEC%5DBreed%20Counting%20S%E3%80%91/">P6180 【[USACO15DEC]Breed Counting S】</a>这篇文章中，我介绍并使用了前缀和的方法来通过该题，这次来讲前缀和的扩展——二维前缀和。</p><a id="more"></a><h2 id="什么是二维前缀和"><a href="#什么是二维前缀和" class="headerlink" title="什么是二维前缀和"></a>什么是二维前缀和</h2><p>首先，并不是针对二维数组中的每一横行作前缀和。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>这次，我们的前缀和数组 $b$ 的定义如下</p><script type="math/tex; mode=display">b_{x,y}=\sum_{i=1}^x\sum_{j=1}^ya_{i,j}</script><p>如果您看不懂或者懒得看这个式子，不妨看看另一个形象一点的介绍</p><p>我们认为 <script type="math/tex">b_{x,y}</script> 就是 <script type="math/tex">a_{x,y}</script> ​左上方矩形的所有数之和。</p><p>我用 Excel 画了这么一张图，其中黄色为原数组 $a$ 黑色为前缀和数组 $b$ 红色部分为二者中相等的部分，也就是说 $b$ 的红色部分代表的是 $a$ 红色部分的和</p><p><img src="https://pic.downk.cc/item/5e6e4ebfe83c3a1e3a0edc10.png" alt=""></p><h3 id="计算方法"><a href="#计算方法" class="headerlink" title="计算方法"></a>计算方法</h3><p>怎么得到 $b$ 数组呢？</p><p>如果我们要得到下图中被框起来的 $b$ 数组</p><p><img src="https://pic.downk.cc/item/5e6e517ee83c3a1e3a0fe10f.png" alt=""></p><p>可以如下图一样操作</p><p><img src="https://pic.downk.cc/item/5e6e52b2e83c3a1e3a103c2c.png" alt=""></p><p>不难发现，也就是加上 $b$ 中上方和左边的数（红色标识），去掉重复的部分（左上方橙色标识），加上原本没有的数（绿色标识）</p><p>给出公式</p><script type="math/tex; mode=display">b_{x,y}=b_{x-1,y}+b_{x,y-1}-b_{x-1,y-1}+a_{x,y}</script><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><p>要知道 $(x1,y1)-(x2,y2)$ 矩阵的值，一样可以由上述思想推出。</p><p>以求 $(2,2)-(3,3)$ 为例</p><p><img src="https://pic.downk.cc/item/5e6e56f4e83c3a1e3a11ae76.png" alt=""></p><p>经过观察可得答案就是 <script type="math/tex">b_{x2,y2}-b_{x1-1,y2}-b_{x2,y1-1}+b_{x1-1,y1-1}</script></p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>先gugugu了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在&lt;a href=&quot;https://answerend42.github.io/Answerend42.github.io/2020/03/08/P6180%20%E3%80%90%5BUSACO15DEC%5DBreed%20Counting%20S%E3%80%91/P6180%20%E3%80%90%5BUSACO15DEC%5DBreed%20Counting%20S%E3%80%91/&quot;&gt;P6180 【[USACO15DEC]Breed Counting S】&lt;/a&gt;这篇文章中，我介绍并使用了前缀和的方法来通过该题，这次来讲前缀和的扩展——二维前缀和。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://answerend42.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="前缀和" scheme="http://answerend42.github.io/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
      <category term="二维前缀和" scheme="http://answerend42.github.io/tags/%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>P1434 [SHOI2002]滑雪</title>
    <link href="http://answerend42.github.io/2020/03/11/lg1434/lg1434/"/>
    <id>http://answerend42.github.io/2020/03/11/lg1434/lg1434/</id>
    <published>2020-03-11T11:09:33.000Z</published>
    <updated>2020-10-06T15:33:00.183Z</updated>
    
    <content type="html"><![CDATA[<p> <a href="https://www.luogu.org/problemnew/show/P1434" target="_blank" rel="noopener">原题链接</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>​    Michael 喜欢滑雪。这并不奇怪，因为滑雪的确很刺激。可是为了获得速度，滑的区域必须向下倾斜，而且当你滑到坡底，你不得不再次走上坡或者等待升降机来载你。Michael 想知道在一个区域中最长的滑坡。区域由一个二维数组给出。数组的每个数字代表点的高度。下面是一个例子：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1   2   3   4   5</span><br><span class="line">16  17  18  19  6</span><br><span class="line">15  24  25  20  7</span><br><span class="line">14  23  22  21  8</span><br><span class="line">13  12  11  10  9</span><br></pre></td></tr></table></figure><p>​    一个人可以从某个点滑向上下左右相邻四个点之一，当且仅当高度会减小。在上面的例子中，一条可行的滑坡为 $24－17－16－1$（从 $24$ 开始，在 $1$ 结束）。当然 $25－24－23－\ldots－3－2－1$ 更长。事实上，这是最长的一条。</p><h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><p><strong>输入格式</strong></p><p>输入的第一行为表示区域的二维数组的行数 $R$ 和列数 $C$。下面是 $R$ 行，每行有 $C$ 个数，代表高度(两个数字之间用 $1$ 个空格间隔)。</p><p><strong>输出格式</strong></p><p>输出区域中最长滑坡的长度。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入1 :</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 5</span><br><span class="line">1 2 3 4 5</span><br><span class="line">16 17 18 19 6</span><br><span class="line">15 24 25 20 7</span><br><span class="line">14 23 22 21 8</span><br><span class="line">13 12 11 10 9</span><br></pre></td></tr></table></figure><p>输出1 :</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">25</span><br></pre></td></tr></table></figure><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>对于 $100\%$ 的数据，$1\leq R,C\leq 100$。</p><h2 id="40分做法（裸dfs）"><a href="#40分做法（裸dfs）" class="headerlink" title="40分做法（裸dfs）"></a>40分做法（裸dfs）</h2><p>​    从每个点出发搜一遍，统计最大值。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, e[<span class="number">105</span>][<span class="number">105</span>], ans;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dx[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span> &#125;, dy[] = &#123; <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    ans = max(len, ans);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> xx = x + dx[i], yy = y + dy[i];</span><br><span class="line">        <span class="keyword">if</span> (xx &lt; <span class="number">1</span> || yy &lt; <span class="number">1</span> || xx &gt; n || yy &gt; m || e[xx][yy] &gt; e[x][y])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        dfs(xx, yy, len + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; e[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            dfs(i, j, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="50分做法（加错误的记忆化）"><a href="#50分做法（加错误的记忆化）" class="headerlink" title="50分做法（加错误的记忆化）"></a>50分做法（加错误的记忆化）</h2><p>​    加入一个错误的记忆化，居然加了10分</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, e[<span class="number">105</span>][<span class="number">105</span>], ans, p[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dx[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span> &#125;, dy[] = &#123; <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x][y] &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> p[x][y];  <span class="comment">// update</span></span><br><span class="line">    <span class="keyword">int</span> maxn = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> xx = x + dx[i], yy = y + dy[i];</span><br><span class="line">        <span class="keyword">if</span> (xx &lt; <span class="number">1</span> || yy &lt; <span class="number">1</span> || xx &gt; n || yy &gt; m || e[xx][yy] &gt; e[x][y])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        maxn = max(maxn, dfs(xx, yy) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p[x][y] = maxn;  <span class="comment">// update</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; e[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            ans = max(dfs(i, j), ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="100分做法（正确的记忆化）"><a href="#100分做法（正确的记忆化）" class="headerlink" title="100分做法（正确的记忆化）"></a>100分做法（正确的记忆化）</h2><p>​    在原先基础上改进一下 <code>e[xx][yy]&gt;e[x][y]</code> 改为 <code>e[xx][yy]&gt;=e[x][y]</code> AC 。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, e[<span class="number">105</span>][<span class="number">105</span>], ans, p[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dx[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span> &#125;, dy[] = &#123; <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x][y] &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> p[x][y];</span><br><span class="line">    <span class="keyword">int</span> maxn = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> xx = x + dx[i], yy = y + dy[i];</span><br><span class="line">        <span class="keyword">if</span> (xx &lt; <span class="number">1</span> || yy &lt; <span class="number">1</span> || xx &gt; n || yy &gt; m || e[xx][yy] &gt;= e[x][y])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        maxn = max(maxn, dfs(xx, yy) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p[x][y] = maxn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; e[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            ans = max(dfs(i, j), ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    记忆化原理，搜到一个搜过的点，如果可以下一步到这个点，直接返回该点的长度，这样两条长度就能拼在一起了。</p><h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><p>​    本文的创作过程受到了<a href="https://www.bilibili.com/video/av92448763?p=2" target="_blank" rel="noopener">嘉持的视频</a>的启发，特此感谢。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; &lt;a href=&quot;https://www.luogu.org/problemnew/show/P1434&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原题链接&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;h
      
    
    </summary>
    
    
      <category term="题解" scheme="http://answerend42.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="深度优先搜索dfs" scheme="http://answerend42.github.io/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2dfs/"/>
    
      <category term="搜索" scheme="http://answerend42.github.io/tags/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="记忆化搜索" scheme="http://answerend42.github.io/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>P1135 奇怪的电梯</title>
    <link href="http://answerend42.github.io/2020/03/11/lg1135/lg1135/"/>
    <id>http://answerend42.github.io/2020/03/11/lg1135/lg1135/</id>
    <published>2020-03-11T08:38:19.000Z</published>
    <updated>2020-10-06T15:28:09.264Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1135" target="_blank" rel="noopener">原题链接</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>​    呵呵，有一天我做了一个梦，梦见了一种很奇怪的电梯。大楼的每一层楼都可以停电梯，而且第 $i$ 层楼$(1 \le i \le N)$ 上有一个数字 $K_i(0 \le K_i \le N)$。电梯只有四个按钮：开，关，上，下。上下的层数等于当前楼层上的那个数字。当然，如果不能满足要求，相应的按钮就会失灵。例如： $3, 3 ,1 ,2 ,5$ 代表了$K_i(K_1=3,K_2=3,…)$，从 $1$ 楼开始。在 $1$ 楼，按“上”可以到 $4$ 楼，按“下”是不起作用的，因为没有 $-2$ 楼。那么，从 $A$ 楼到 $B$ 楼至少要按几次按钮呢？</p><h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><p><strong>输入格式</strong></p><p>共二行。</p><p>第一行为 $3$ 个用空格隔开的正整数，表示 $N,A,B(1≤N≤200, 1≤A,B≤N)$。</p><p>第二行为 $N$ 个用空格隔开的非负整数，表示 $K_i$。</p><p><strong>输出格式</strong></p><p>一行，即最少按键次数,若无法到达，则输出 $−1$。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入1 :</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 1 5</span><br><span class="line">3 3 1 2 5</span><br></pre></td></tr></table></figure><p>输出1 :</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="解法（bfs）"><a href="#解法（bfs）" class="headerlink" title="解法（bfs）"></a>解法（bfs）</h2><p>​    一道很简单的 bfs 裸题，根据题意可知，每一层至多有两种情况，向上或者向下当前层数，既然要求最少按几次按钮当然是用 bfs。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> f,step;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch=getchar();<span class="keyword">int</span> ret=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">'0'</span>||ch&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">'-'</span>)f=-f;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">'0'</span>&amp;&amp;ch&lt;=<span class="string">'9'</span>)&#123;ret=(ret&lt;&lt;<span class="number">1</span>)+(ret&lt;&lt;<span class="number">3</span>)+ch-<span class="string">'0'</span>;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">queue</span>&lt;Node&gt; q;</span><br><span class="line"><span class="keyword">int</span> n=read(),a=read(),b=read(),p[<span class="number">205</span>],book[<span class="number">100005</span>];</span><br><span class="line">Node t;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> d[]=&#123;<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(book,<span class="number">-1</span>,<span class="keyword">sizeof</span>(book));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        p[i]=read();</span><br><span class="line">    Node t1;</span><br><span class="line">    t1.f=a;</span><br><span class="line">    t1.step=<span class="number">0</span>;</span><br><span class="line">    book[a]=<span class="number">0</span>;</span><br><span class="line">    q.push(t1);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        t=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">if</span>(t.f==b)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> tf;</span><br><span class="line">            <span class="keyword">if</span>(d[i]==<span class="number">1</span>)</span><br><span class="line">                tf=t.f+p[t.f];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                tf=t.f-p[t.f];</span><br><span class="line">            <span class="keyword">if</span>(tf&lt;<span class="number">1</span>||tf&gt;n||book[tf]==<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            book[tf]=<span class="number">1</span>;</span><br><span class="line">            Node t2;</span><br><span class="line">            t2.f=tf;</span><br><span class="line">            t2.step=t.step+<span class="number">1</span>;</span><br><span class="line">            q.push(t2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">if</span>(t.f==b)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,t.step);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-1"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P1135&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原题链接&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerl
      
    
    </summary>
    
    
      <category term="题解" scheme="http://answerend42.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="广度优先搜索bfs" scheme="http://answerend42.github.io/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2bfs/"/>
    
      <category term="搜索" scheme="http://answerend42.github.io/tags/%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>P1057 传球游戏</title>
    <link href="http://answerend42.github.io/2020/03/09/lg1057/lg1057/"/>
    <id>http://answerend42.github.io/2020/03/09/lg1057/lg1057/</id>
    <published>2020-03-09T07:50:09.000Z</published>
    <updated>2020-10-06T15:31:46.353Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h2><p>​    有 $n$ 个人围坐成环，从 $1$ 开始传递，每次可将球传给相邻的人，问 $m$ 次传递后回到 $1$ 的方案数。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>​    这一题很容易想到用搜索算法，但是会超时。我们不妨这样想，如果存在 $m$ 次传递后回到 $1$ 的情况，也就是意味着 $m-1$ 次传递到了 $n$ 或者 $2$ ， $m-2$ 次传递到了 $n-1$ 或者 $3$ 或者 $1$ 。我们就可以脑洞大开一下，求解传递 $k$ 次到 $p$ 的方案数，不就是传递 $k-1$ 次到 $p-1$ 和 $p+1$ 的方案数之和吗？（当然， $p=1$ 时是 $n$ 和 $2$ ）这就是状态的转移。</p><p>​    在这里，我用 <code>f[i][j]</code>  表示经过 $j$ 次传递到 $i$ 的方案数。</p><p>​    有状态转移公式</p><script type="math/tex; mode=display">f_{i,j}=f_{i-1,j-1}+f_{i+1,j-1} (i\ne1,i\ne n)</script><script type="math/tex; mode=display">f_{i,j}=f_{n,j-1}+f_{i+1,j-1} (i=1)</script><script type="math/tex; mode=display">f_{i,j}=f_{i-1,j-1}+f_{1,j-1} (i=n)</script><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, f[<span class="number">35</span>][<span class="number">35</span>];</span><br><span class="line"><span class="comment">// f[i][j]=f[i-1][j-1]+f[i+1][j-1]</span></span><br><span class="line"><span class="comment">// f[i][j]表示传到了i 传递了j次的方案数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">1</span>)</span><br><span class="line">                f[i][j] = f[n][j - <span class="number">1</span>] + f[i + <span class="number">1</span>][j - <span class="number">1</span>];  <span class="comment">// 1可以从n传，也可以从n+1传</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i == n)</span><br><span class="line">                f[i][j] = f[<span class="number">1</span>][j - <span class="number">1</span>] + f[i - <span class="number">1</span>][j - <span class="number">1</span>];  <span class="comment">// n可以从1传，也可以从n-1传</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                f[i][j] = f[i - <span class="number">1</span>][j - <span class="number">1</span>] + f[i + <span class="number">1</span>][j - <span class="number">1</span>];  <span class="comment">//其余都是i+1,i-1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[<span class="number">1</span>][m];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题意简述&quot;&gt;&lt;a href=&quot;#题意简述&quot; class=&quot;headerlink&quot; title=&quot;题意简述&quot;&gt;&lt;/a&gt;题意简述&lt;/h2&gt;&lt;p&gt;​    有 $n$ 个人围坐成环，从 $1$ 开始传递，每次可将球传给相邻的人，问 $m$ 次传递后回到 $1$ 的方案数
      
    
    </summary>
    
    
      <category term="题解" scheme="http://answerend42.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="动态规划" scheme="http://answerend42.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>P6180 【[USACO15DEC]Breed Counting S】</title>
    <link href="http://answerend42.github.io/2020/03/08/lg6180/lg6180/"/>
    <id>http://answerend42.github.io/2020/03/08/lg6180/lg6180/</id>
    <published>2020-03-08T07:54:42.000Z</published>
    <updated>2020-10-06T15:26:14.910Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P6180" target="_blank" rel="noopener">原题链接</a></p><h2 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h2><p>  给出 $n$ 头奶牛，每头可分为三种，对于 $q$ 次询问，给出区间内各种奶牛的数量。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题目的数据范围限制为 $N,Q\leq10^5$ ，肯定不能够使用暴力对于每一个区间跑一遍统计。这一题有只要求查询而不要求修改，很自然就想到了前缀和。</p><h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><p>那么什么是前缀和呢？</p><p>根据<a href="https://oi-wiki.org/basic/prefix-sum/" target="_blank" rel="noopener">OI Wiki 上的解释</a></p><blockquote><p>前缀和是一种重要的预处理，能大大降低查询的时间复杂度。我们可以简单理解为“数列的前 $n$ 项的和”。</p></blockquote><p>如果用数组 $a$ 和其前缀和数组 $b$ 表示出来</p><p>$a_1=1,a_2=5,a_3=3,a_4=2,…$</p><p>则数组 $b$</p><p>$b_1=1,b_2=6,b_3=9,b_4=11,…$</p><p>不难推出式子</p><script type="math/tex; mode=display">b_i=b_{i-1}+a_i</script><p>如果要查询数组 $a$ 从 $l$ 到 $r$ 之间所有数的和，只用输出 <script type="math/tex">b_r-b_{l-1}</script>​ </p><p>原理：</p><script type="math/tex; mode=display">b_r=\sum_{i=1}^{r}a_i</script><script type="math/tex; mode=display">b_{l-1}=\sum_{i=1}^{l-1}a_i</script><p>注意，一定是 $l-1$ 如果是 $l$ 就会将 $a_l$ 减去</p><p>根据上述，给出代码如下</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">'0'</span> || ch &gt; <span class="string">'9'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">'-'</span>)</span><br><span class="line">            f = -f;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">        ret = (ret &lt;&lt; <span class="number">1</span>) + (ret &lt;&lt; <span class="number">3</span>) + ch - <span class="string">'0'</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> n, q, a[<span class="number">2</span>][N], b[<span class="number">2</span>][N], c[<span class="number">2</span>][N];</span><br><span class="line"><span class="comment">// a[0],b[0],c[0]为原始数组</span></span><br><span class="line"><span class="comment">// a[1],b[1],c[1]为对应的前缀和数组</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = read();</span><br><span class="line">    q = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = read();</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="number">1</span>)</span><br><span class="line">            a[<span class="number">0</span>][i]++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (t == <span class="number">2</span>)</span><br><span class="line">            b[<span class="number">0</span>][i]++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (t == <span class="number">3</span>)</span><br><span class="line">            c[<span class="number">0</span>][i]++;</span><br><span class="line">        a[<span class="number">1</span>][i] = a[<span class="number">1</span>][i - <span class="number">1</span>] + a[<span class="number">0</span>][i];</span><br><span class="line">        b[<span class="number">1</span>][i] = b[<span class="number">1</span>][i - <span class="number">1</span>] + b[<span class="number">0</span>][i];</span><br><span class="line">        c[<span class="number">1</span>][i] = c[<span class="number">1</span>][i - <span class="number">1</span>] + c[<span class="number">0</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = read(), r = read();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>, a[<span class="number">1</span>][r] - a[<span class="number">1</span>][l - <span class="number">1</span>], b[<span class="number">1</span>][r] - b[<span class="number">1</span>][l - <span class="number">1</span>], c[<span class="number">1</span>][r] - c[<span class="number">1</span>][l - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>前缀和的应用并不只上述这么简单，许多看似基础的算法也是如此，往往可以通过一些有趣的改进拓展到更多地方。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P6180&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原题链接&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题意简述&quot;&gt;&lt;a href=&quot;#题意简述&quot; class=&quot;headerl
      
    
    </summary>
    
    
      <category term="题解" scheme="http://answerend42.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="前缀和" scheme="http://answerend42.github.io/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
  </entry>
  
</feed>
